//
// Created by Rafael Venetikides on 24/03/25.
//

#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include "../include/stack_operations.h"
#include "../include/operations.h"

#include "../include/serial_operations.h"

/**
 * @brief Generates assembly code from a postfix expression
 *
 * @param postfix pointer to the postfix expression
 * @param outAsm output file
 */
void generateAssemblyFromPostfix(const char *postfix, FILE *outAsm) {

    const char *p = postfix;

    while (*p) {
        while (isspace((unsigned char)*p)) {
            p++;
        }
        if (!*p) break;

        if (strchr("+-*/|%^", *p)) {
            char op = *p;
            p++;

            switch (op) {
                case '+':
                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, ";  Moving values from op 1\n"
                                    "    MOV R18, R16         ; copy low byte op1\n"
                                    "    MOV R19, R17         ; copy high byte op1\n");

                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, "   CALL op_add_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                    "   PUSH R23\n\n");
                break;
                case '-':
                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, ";  Moving values from op 1\n"
                                    "    MOV R18, R16         ; copy low byte op1\n"
                                    "    MOV R19, R17         ; copy high byte op1\n\n");

                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, "   CALL op_sub_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                   "   PUSH R23\n\n");
                break;
                case '*':
                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, ";  Moving values from op 1\n"
                                "    MOV R18, R16         ; copy low byte op1\n"
                                "    MOV R19, R17         ; copy high byte op1\n\n");

                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, "   CALL op_mult_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                   "   PUSH R23\n\n");
                break;
                case '|':

                    fprintf(outAsm, "    POP R17         ; R17=0x40 (A high)\n"
                                    "    POP R16         ; R16=0x00 (A low)   => Divisor = R17:R16 = 0x4000 (2.0)\n\n"
                                    "    ; Pop B (0x4800) diretamente para os registradores do Dividendo (R19:R18)\n"
                                    "    POP R19         ; R19=0x48 (B high)\n"
                                    "    POP R18         ; R18=0x00 (B low)   => Dividendo = R19:R18 = 0x4800 (8.0)\n\n");

                    fprintf(outAsm, "   CALL op_div_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                   "   PUSH R23\n\n");
                break;
                case '/':
                    fprintf(outAsm, "    POP R17         ; R17=0x40 (A high)\n"
                                    "    POP R16         ; R16=0x00 (A low)   => Divisor = R17:R16 = 0x4000 (2.0)\n\n"
                                    "    ; Pop B (0x4800) diretamente para os registradores do Dividendo (R19:R18)\n"
                                    "    POP R19         ; R19=0x48 (B high)\n"
                                    "    POP R18         ; R18=0x00 (B low)   => Dividendo = R19:R18 = 0x4800 (8.0)\n\n");

                    fprintf(outAsm, "   CALL op_div_int_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                   "   PUSH R23\n\n");
                break;
                case '%':
                    fprintf(outAsm, "    POP R17         ; R17=0x40 (A high)\n"
                                    "    POP R16         ; R16=0x00 (A low)   => Divisor = R17:R16 = 0x4000 (2.0)\n\n"
                                    "    ; Pop B (0x4800) diretamente para os registradores do Dividendo (R19:R18)\n"
                                    "    POP R19         ; R19=0x48 (B high)\n"
                                    "    POP R18         ; R18=0x00 (B low)   => Dividendo = R19:R18 = 0x4800 (8.0)\n\n");

                    fprintf(outAsm, "   CALL op_rem_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                   "   PUSH R23\n\n");
                break;
                case '^':
                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, ";  Moving values from op 1\n"
                                    "    MOV R18, R16         ; copy low byte op1\n"
                                    "    MOV R19, R17         ; copy high byte op1\n\n");

                    gen_pop_16bit(outAsm);

                    fprintf(outAsm, "   CALL op_pow_16bits\n\n");

                    fprintf(outAsm,"   PUSH R22\n"
                                   "   PUSH R23\n\n");
                break;
                default:
                    printf("; Unknown operator '%c'\n", op);
                    fprintf(outAsm, "; Unkown operator");
                break;
            }
        } else {
            // É um número, então vamos ler até espaço ou operador
            char temp[64];
            int i = 0;

            // Copia os caracteres do número para temp[]
            while (*p
                && !isspace((unsigned char)*p)
                && !strchr("+-*/|%^", *p))
            {
                temp[i++] = *p;
                p++;
            }
            temp[i] = '\0'; // fim de string

            // Convertemos para int (ou outra função se precisar half-precision etc.)
            float valFloat = strtof(temp, NULL);

            // Agora geramos as instruções de push de 16 bits
            gen_push_16bit(valFloat, outAsm);
        }
    }
    fprintf(outAsm, "   POP R23\n"
                    "   POP R22\n\n");
    fprintf(outAsm, "   CALL print\n\n");
}

void write_functions(FILE *outAsm) {
    fprintf(outAsm, "RJMP program_start\n\n");
    op_add_16bits(outAsm);
    op_sub_16bits(outAsm);
    op_mult_16bits(outAsm);
    op_div_16bits(outAsm);
    op_div_int_16bits(outAsm);
    op_rem_16bits(outAsm);
    op_power(outAsm);
    serial_out(outAsm);
}

/**
 *  @brief Adição de dois números de ponto flutuante de meia precisão
 *
 *  @param outAsm Dados de saída do arquivo
 */
void op_add_16bits(FILE *outAsm) {

    fprintf(outAsm, "op_add_16bits:\n\n");
    fprintf(outAsm, "   PUSH R19\n"
                    "   PUSH R18\n");

    fprintf(outAsm, "; Op1 -> R19:R18\n");
    fprintf(outAsm, "; Op2 -> R17:R16\n\n");

    fprintf(outAsm, "    SBRC R19, 7\n"
                    "    LDI R30, 1    ; sinal_A = 1\n"
                    "    SBRS R19, 7\n"
                    "    LDI R30, 0    ; sinal_A = 0\n\n");

    fprintf(outAsm, "    SBRC R17, 7\n"
                    "    LDI R31, 1    ; sinal_B = 1\n"
                    "    SBRS R17, 7\n"
                    "    LDI R31, 0    ; sinal_B = 0\n\n");

    align_exp(outAsm);

    fprintf(outAsm, "; Agora R30 = sinal_A, R31 = sinal_B\n"
                    "    ; Compare:\n"
                    "    CP R30, R31\n"
                    "    BREQ same_signs");

    fprintf(outAsm, "; Sinais diferentes - subtração\n"
                    "    ; Determinar qual valor é maior\n"
                    "    CP R23, R25         ; compara byte alto das mantissas\n"
                    "    BRNE high_diff\n"
                    "    CP R22, R24         ; se bytes altos iguais, compara bytes baixos\n\n");

    fprintf(outAsm, "high_diff:\n"
                    "    BRLO b_greater      ; se A < B\n"
                    "\n"
                    "    ; A >= B: R23:R22 - R25:R24\n"
                    "    SUB R22, R24\n"
                    "    SBC R23, R25\n"
                    "    MOV R27, R30        ; sinal do resultado = sinal de A\n"
                    "    RJMP normalize\n\n");

    fprintf(outAsm, "b_greater:\n"
                    "    ; B > A: R25:R24 - R23:R22\n"
                    "    SUB R24, R22\n"
                    "    SBC R25, R23\n"
                    "    MOV R27, R31        ; sinal do resultado = sinal de B\n"
                    "    ; Troca R25:R24 ? R23:R22\n"
                    "    MOV R22, R24\n"
                    "    MOV R23, R25\n"
                    "    RJMP normalize\n\n");

    fprintf(outAsm, "same_signs:\n"
                    "    ; Sinais iguais - adição\n"
                    "    ADD R22, R24        ; soma bytes baixos\n"
                    "    ADC R23, R25        ; soma bytes altos com carry\n"
                    "    MOV R27, R30        ; sinal do resultado = sinal de A (ou B, são iguais)\n\n");

    fprintf(outAsm, "normalize:\n"
                    "    ; Verificar se houve overflow na soma e ajustar\n"
                    "    SBRC R23, 3         ; verifica se bit 3 está ligado (overflow)\n"
                    "    RJMP adjust_overflow\n"
                    "\n"
                    "    ; Verificar subflow (mantissa zerada)\n"
                    "    MOV R28, R23\n"
                    "    OR R28, R22         ; R28 = R23 | R22\n"
                    "    BREQ result_zero    ; se resultado for zero\n\n");

    fprintf(outAsm, "    ; Normalizar o resultado (deslocar à esquerda até bit implícito estar na posição correta)\n"
                    "normalize_loop:\n"
                    "    SBRC R23, 2         ; verifica se bit implícito está na posição\n"
                    "    RJMP end_normalize  ; se sim, fim da normalização\n"
                    "    \n"
                    "    LSL R22             ; desloca mantissa à esquerda\n"
                    "    ROL R23\n"
                    "    DEC R26             ; decrementa expoente\n"
                    "    \n"
                    "    ; Verificar subflow de expoente\n"
                    "    CPI R26, 0\n"
                    "    BRNE normalize_loop\n"
                    "    \n"
                    "    ; Resultado denormalizado\n"
                    "    RJMP end_normalize\n\n");

    fprintf(outAsm, "adjust_overflow:\n"
                    "    LSR R23             ; desloca à direita para ajustar overflow\n"
                    "    ROR R22\n"
                    "    INC R26             ; incrementa expoente\n"
                    "    \n"
                    "    ; Verificar overflow de expoente (máx 31 = 0x1F)\n"
                    "    CPI R26, 0x1F\n"
                    "    BRNE end_normalize\n"
                    "    \n"
                    "    ; Overflow - definir resultado como infinito\n"
                    "    LDI R23, 0x00\n"
                    "    LDI R22, 0x00\n"
                    "    LDI R26, 0x1F       ; expoente máximo\n"
                    "    RJMP end_normalize\n\n");

    fprintf(outAsm, "result_zero:\n"
                    "    LDI R26, 0          ; expoente zero\n"
                    "    LDI R27, 0          ; sinal positivo\n\n");

    fprintf(outAsm, "end_normalize:\n"
                    "    ; Montar resultado final em formato half-precision\n"
                    "    ANDI R23, 0x03      ; manter apenas bits 9-8 da mantissa\n"
                    "    \n"
                    "    ; Adicionar expoente\n"
                    "    LSL R26             ; desloca expoente para posição correta\n"
                    "    LSL R26\n"
                    "    ANDI R26, 0x7C      ; garante que apenas bits de expoente estejam setados\n"
                    "    OR R23, R26         ; adiciona expoente ao byte alto\n"
                    "    \n"
                    "    ; Adicionar bit de sinal\n"
                    "    CPI R27, 1\n"
                    "    BRNE no_sign\n"
                    "    ORI R23, 0x80       ; seta bit de sinal se negativo\n\n");

    fprintf(outAsm, "no_sign:\n"
                    "   POP R18\n"
                    "   POP R19\n"
                    "   RET\n\n");
}

/**
 * @brief Alinhamento dos expoentes para fazer o cálculo de adição
 *
 * @param outAsm Dados de saída do arquivo
 */
void align_exp(FILE *outAsm) {
    fprintf(outAsm, "; Extrair expoente de R19 (operando 1)\n"
                    "    MOV R20, R19        ; copia high byte \n"
                    "    ANDI R20, 0x7C ; limpa o bit de sinal, deixa os bits 14-10 alinhados\n"
                    "    LSR R20             ; >>1 para alinhar com bits 0–4\n"
                    "    LSR R20             ; Agora R20 tem expoente1\n\n");

    fprintf(outAsm, "; Extrair expoente de R17 (operando 2)\n"
                    "    MOV R21, R17\n"
                    "    ANDI R21, 0x7C\n"
                    "    LSR R21\n"
                    "    LSR R21             ; Agora R21 tem expoente2\n\n");

    fprintf(outAsm, "; Extrair mantissas (10 bits cada, incluindo bit implícito)\n"
                    "    ; Mantissa de A (R19:R18)\n"
                    "    MOV R22, R18        ; byte baixo\n"
                    "    MOV R23, R19        ; byte alto\n"
                    "    ANDI R23, 0x03      ; isola bits 1-0 (bits 9-8 da mantissa)\n\n");

    fprintf(outAsm, "; Adiciona bit implícito se não for denormalizado\n"
                    "    CPI R20, 0          ; verifica se expoente é zero\n"
                    "    BREQ no_implicit_a  ; se zero, não adiciona bit implícito\n"
                    "    ORI R23, 0x04       ; adiciona bit implícito (bit 10 da mantissa)\n\n");

    fprintf(outAsm, "no_implicit_a:\n"
                    "\n"
                    "    ; Mantissa de B (R17:R16)\n"
                    "    MOV R24, R16        ; byte baixo\n"
                    "    MOV R25, R17        ; byte alto\n"
                    "    ANDI R25, 0x03      ; isola bits 1-0 (bits 9-8 da mantissa)\n"
                    "    \n"
                    "    ; Adiciona bit implícito se não for denormalizado\n"
                    "    CPI R21, 0          ; verifica se expoente é zero\n"
                    "    BREQ no_implicit_b  ; se zero, não adiciona bit implícito\n"
                    "    ORI R25, 0x04       ; adiciona bit implícito (bit 10 da mantissa)\n\n");

    fprintf(outAsm, "no_implicit_b:\n"
                    "\n"
                    "; Determinar o expoente maior e alinhar mantissas\n"
                    "    CP R20, R21\n"
                    "    BRGE exp_a_ge_b     ; se expoente A >= B, salta\n"
                    "\n"
                    "; Caso B > A: alinhando mantissa A\n"
                    "    MOV R26, R21        ; salva expoente maior (B)\n"
                    "    SUB R21, R20        ; diferença entre expoentes\n\n");

    fprintf(outAsm, "shift_a:\n"
                    "    CPI R21, 0          ; verifica se ainda há deslocamentos a fazer\n"
                    "    BREQ end_shift_a\n"
                    "    LSR R23             ; desloca mantissa A para direita\n"
                    "    ROR R22\n"
                    "    DEC R21\n"
                    "    RJMP shift_a\n"
                    "end_shift_a:\n"
                    "    RJMP aligned\n\n");

    fprintf(outAsm, "exp_a_ge_b:\n"
                    "; Caso A >= B: alinhando mantissa B\n"
                    "    MOV R26, R20        ; salva expoente maior (A)\n"
                    "    SUB R20, R21        ; diferença entre expoentes\n"
                    "\n"
                    "shift_b:\n"
                    "    CPI R20, 0          ; verifica se ainda há deslocamentos a fazer\n"
                    "    BREQ end_shift_b\n"
                    "    LSR R25             ; desloca mantissa B para direita\n"
                    "    ROR R24\n"
                    "    DEC R20\n"
                    "    RJMP shift_b\n"
                    "end_shift_b:\n\n"
                    "aligned:\n");
}

void op_sub_16bits(FILE *outAsm) {

    fprintf(outAsm, "op_sub_16bits:\n\n");

    fprintf(outAsm, "   ORI R19, 0x80\n\n");

    fprintf(outAsm, "   CALL op_add_16bits\n\n");

    fprintf(outAsm, "   RET\n\n");
}

void op_mult_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_mult_16bits:\n"
                    "   ; --- Extrair sinais ---\n"
                    "         MOV R30, R19\n"
                    "   ANDI R30, 0x80\n"
                    "   MOV R31, R17\n"
                    "   ANDI R31, 0x80\n"
                    "   EOR R30, R31       ; Sinal do resultado\n\n"

                    "; --- Verificar zero ---\n"
                    "; Se expoente e mantissa forem zero, é zero\n"
                    "   MOV R20, R19\n"
                    "   ANDI R20, 0x7C\n"
                    "   TST R20\n"
                    "   BRNE check_op2_zero\n"
                    "   MOV R24, R18\n"
                    "   MOV R25, R19\n"
                    "   ANDI R25, 0x03\n"
                    "   OR R24, R25\n"
                    "   BRNE check_op2_zero\n"
                    "   ; Op1 é zero\n"
                    "   CLR R22\n"
                    "   CLR R23\n"
                    "   OR R23, R30\n"
                    "   RET\n\n"

                    "check_op2_zero:\n"
                    "   MOV R21, R17\n"
                    "   ANDI R21, 0x7C\n"
                    "   TST R21\n"
                    "   BRNE extract_fields\n"
                    "   MOV R24, R16\n"
                    "   MOV R25, R17\n"
                    "   ANDI R25, 0x03\n"
                    "   OR R24, R25\n"
                    "   BRNE extract_fields\n"
                    "   ; Op2 é zero\n"
                    "   CLR R22\n"
                    "   CLR R23\n"
                    "   OR R23, R30\n"
                    "   RET\n"

                    "extract_fields:\n"
                    "; --- Extrair mantissas e expoentes ---\n"
                    "        ; Operando 1\n"
                    "   MOV R24, R18\n"
                    "   MOV R25, R19\n"
                    "   ANDI R25, 0x03\n"
                    "   MOV R20, R19\n"
                    "   ANDI R20, 0x7C\n"
                    "   LSR R20\n"
                    "   LSR R20\n"
                    "   CPI R20, 0\n"
                    "   BRNE op1_norm\n"
                    "   ORI R25, 0x00\n"
                    "   LDI R20, 1\n"
                    "   RJMP op1_ready\n"
                    "op1_norm:\n"
                    "   ORI R25, 0x04\n"
                    "op1_ready:\n"

                    "   ; Operando 2\n"
                    "   MOV R26, R16\n"
                    "   MOV R27, R17\n"
                    "   ANDI R27, 0x03\n"
                    "   MOV R21, R17\n"
                    "   ANDI R21, 0x7C\n"
                    "   LSR R21\n"
                    "   LSR R21\n"
                    "   CPI R21, 0\n"
                    "   BRNE op2_norm\n"
                    "   ORI R27, 0x00\n"
                    "   LDI R21, 1\n"
                    "   RJMP op2_ready\n"
                    "op2_norm:\n"
                    "   ORI R27, 0x04\n"
                    "op2_ready:\n"

                    "; --- Calcular expoente ---\n"
                    "   ADD R20, R21\n"
                    "   SUBI R20, 15\n\n"

                    "; --- Multiplicar mantissas: (R25:R24) * (R27:R26) ---\n"
                    "; Resultado 32 bits em R0-R3\n"
                    "   CLR R0\n"
                    "   CLR R1\n"
                    "   CLR R2\n"
                    "   CLR R3\n\n"

                    "   MUL R24, R26\n"
                    "   MOV R0, r0\n"
                    "   MOV R1, r1\n\n"

                    "   MUL R24, R27\n"
                    "   ADD R1, r0\n"
                    "   ADC R2, r1\n"
                    "   CLR r18\n"
                    "   ADC R3, r18\n\n"

                    "   MUL R25, R26\n"
                    "   ADD R1, r0\n"
                    "   ADC R2, r1\n"
                    "   CLR r18\n"
                    "   ADC R3, r18\n\n"

                    "   MUL R25, R27\n"
                    "   ADD R2, r0\n"
                    "   ADC R3, r1\n\n"

                    "; Produto em R3:R2:R1:R0 (22 bits úteis)\n"
                    "; Verifica overflow e ajusta expoente\n"
                    "   SBRC R2, 5\n"
                    "   RJMP shift_prod\n"
                    "   RJMP format_mantissa\n"

                    "shift_prod:\n"
                    "   LSR R3\n"
                    "   ROR R2\n"
                    "   ROR R1\n"
                    "   ROR R0\n"
                    "   INC R20\n\n"

                    "format_mantissa:\n"
                    "; Verificar overflow/underflow de expoente\n"
                    "   CPI R20, 31\n"
                    "   BRGE exp_overflow\n"
                    "   CPI R20, 1\n"
                    "   BRLT exp_underflow\n\n"

                    "; Extrair 10 bits após o bit implícito (bit 20)\n"
                    "; Byte alto: bits 19-18 (bits 3-2 de R2)\n"
                    "; Byte baixo: bits 17-10 (bits 1-0 de R2 + 7-2 de R1)\n\n"

                    "   MOV R23, R30\n"
                    "   MOV R24, R20\n"
                    "   LSL R24\n"
                    "   LSL R24\n"
                    "   ANDI R24, 0x7C\n"
                    "   OR R23, R24\n\n"

                    "   MOV R24, R2\n"
                    "   ANDI R24, 0x0C\n"
                    "   LSR R24\n"
                    "   LSR R24\n"
                    "   OR R23, R24\n\n"

                    "   MOV R22, R2\n"
                    "   ANDI R22, 0x03\n"
                    "   LSL R22\n"
                    "   LSL R22\n"
                    "   LSL R22\n"
                    "   LSL R22\n"
                    "   LSL R22\n"
                    "   LSL R22\n"
                    "   MOV R24, R1\n"
                    "   ANDI R24, 0xFC\n"
                    "   LSR R24\n"
                    "   LSR R24\n"
                    "   OR R22, R24\n"
                    "   RET\n\n"

                    "exp_overflow:\n"
                    "   CLR R22\n"
                    "   LDI R23, 0x7C\n"
                    "   OR R23, R30\n"
                    "   RET\n\n"

                    "exp_underflow:\n"
                    "   CLR R22\n"
                    "   CLR R23\n"
                    "   OR R23, R30\n"
                    "   RET\n\n");
}

void op_div_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_div_16bits:\n"
                    "    ; --- Tratamento do Sinal ---\n"
                    "    MOV   R30, R19\n"
                    "    ANDI  R30, 0x80         ; Sinal de A\n"
                    "    MOV   R31, R17\n"
                    "    ANDI  R31, 0x80         ; Sinal de B\n"
                    "    EOR   R30, R31          ; R30 = Sinal do Resultado (0x80 ou 0x00)\n"
                    "\n"
                    "    ; --- Tratamento de Casos Especiais ---\n"
                    "    ; Verifica se A é NaN ou Infinito\n"
                    "    MOV   R20, R19          ; R20 = A_high\n"
                    "    ANDI  R20, 0x7C         ; Isola o expoente de A\n"
                    "    CPI   R20, 0x7C         ; Expoente = 0x1F?\n"
                    "    BREQ  is_exp_1f_A\n"
                    "    RJMP  check_b_nan_inf\n"
                    "is_exp_1f_A:\n"
                    "    ; A possui expoente 0x1F (Inf ou NaN)\n"
                    "    MOV   R21, R19          ; Verifica a mantissa de A\n"
                    "    ANDI  R21, 0x03\n"
                    "    OR    R21, R18          ; R21 = mantissa baixa | bits altos da mantissa\n"
                    "    BREQ  a_is_inf_check    ; If equal (mantissa is 0), branch locally (A is Inf)\n"
                    "    RJMP  result_nan_quietA ; If not equal (original condition), jump far (A is NaN)\n"
                    "a_is_inf_check:\n"
                    "\n"
                    "    ; A é Infinito\n"
                    "    MOV   R22, R17          ; R22 = B_high\n"
                    "    ANDI  R22, 0x7C         ; Isola expoente de B\n"
                    "    CPI   R22, 0x7C         ; B também 0x1F?\n"
                    "    BREQ  is_exp_1f_B\n"
                    "    RJMP  pack_infinity\n"
                    "is_exp_1f_B:\n"
                    "    ; B também é Inf/NaN\n"
                    "    MOV   R23, R17          ; Verifica mantissa de B\n"
                    "    ANDI  R23, 0x03\n"
                    "    OR    R23, R16          ; R23 = mantissa de B\n"
                    "    BREQ  b_is_inf          ; If equal (mantissa is 0), branch locally\n"
                    "    RJMP  result_nan_quietB ; If not equal (original condition), jump far (B is NaN)\n"
                    "b_is_inf:\n"
                    "    ; Ambos Inf →  Inf/Inf = Indeterminado → NaN\n"
                    "    RJMP  result_nan\n"
                    "\n"
                    "check_b_nan_inf:\n"
                    "    ; Verifica se B é NaN ou Infinito\n"
                    "    MOV   R22, R17\n"
                    "    ANDI  R22, 0x7C\n"
                    "    CPI   R22, 0x7C\n"
                    "    BREQ  b_is_nan_or_inf ; If equal, branch locally to handle NaN/Inf\n"
                    "    RJMP  check_a_zero    ; If not equal (original condition), jump far\n"
                    "b_is_nan_or_inf:\n"
                    "    ; This is the code that originally followed the BRNE\n"
                    "    MOV   R23, R17\n"
                    "    ANDI  R23, 0x03\n"
                    "    OR    R23, R16\n"
                    "    ; --- Make sure the fix for BRNE result_nan_quietB is still here ---\n"
                    "    ; Example: Assuming that fix was applied and worked:\n"
                    "    BREQ b_is_inf_check2  ; If equal (mantissa 0 -> B is Inf), branch locally\n"
                    "    RJMP result_nan_quietB ; If not equal (mantissa non-zero -> B is NaN)\n"
                    "b_is_inf_check2:\n"
                    "    ; B is Infinito e A é finito → resultado zero\n"
                    "    CLR   R22             ; Resultado baixa = 0\n"
                    "    MOV   R23, R30        ; Resultado alta = Sinal\n"
                    "    RET\n"
                    "\n"
                    "check_a_zero:\n"
                    "    ; Verifica se A é zero (expoente e mantissa 0)\n"
                    "    MOV   R20, R19\n"
                    "    ANDI  R20, 0x7F         ; Ignora sinal\n"
                    "    OR    R20, R18\n"
                    "    BREQ  a_is_zero_check   ; If equal (A is 0), branch locally\n"
                    "    RJMP  check_b_zero      ; If not equal (original condition), jump far (A is not 0)\n"
                    "a_is_zero_check:\n"
                    "    ; A = zero\n"
                    "    MOV   R22, R17          ; Verifica se B é zero\n"
                    "    ANDI  R22, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    BREQ  b_is_also_zero    ; If equal (B is 0), branch locally (handle 0/0)\n"
                    "    RJMP  div_a_is_zero     ; If not equal (original condition), jump far (B != 0, result is 0)\n"
                    "b_is_also_zero:\n"
                    "    RJMP  result_nan        ; 0/0 → NaN\n"
                    "\n"
                    "div_a_is_zero:\n"
                    "    CLR   R22               ; Resultado baixa = 0\n"
                    "    MOV   R23, R30          ; Resultado alta = Sinal\n"
                    "    RET\n"
                    "\n"
                    "check_b_zero:\n"
                    "    ; Verifica se B é zero\n"
                    "    MOV   R22, R17\n"
                    "    ANDI  R22, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    BRNE  continue_division  ; Se B ≠ 0, prossegue com a divisão\n"
                    "    ; Divisão por zero → Infinito\n"
                    "    LDI   R22, 0x00         ; Mantissa = 0\n"
                    "    LDI   R23, 0x7C         ; Expoente = 0x1F\n"
                    "    OR    R23, R30          ; Adiciona sinal\n"
                    "    RET\n"
                    "\n"
                    "; --- Divisão Normal ---\n"
                    "continue_division:\n"
                    "    ; Extrai os Expoentes\n"
                    "    MOV   R20, R19\n"
                    "    ANDI  R20, 0x7C         ; Expoente de A\n"
                    "    LSR   R20\n"
                    "    LSR   R20               ; Expoente A (viés) [0..31]\n"
                    "    MOV   R21, R17\n"
                    "    ANDI  R21, 0x7C         ; Expoente de B\n"
                    "    LSR   R21\n"
                    "    LSR   R21               ; Expoente B\n"
                    "\n"
                    "    ; Extrai as Mantissas e adiciona o bit implícito\n"
                    "    MOV   R24, R18          ; Mantissa baixa de A\n"
                    "    MOV   R25, R19          ; Mantissa alta de A\n"
                    "    ANDI  R25, 0x03         ; Remove bits de expoente/sinal\n"
                    "    CPI   R20, 0            ; Verifica se A é denormal\n"
                    "    BRNE  a_normal\n"
                    "    LDI   R20, 1            ; Para denormal, expoente efetivo = 1 (sem bit implícito)\n"
                    "    RJMP  a_ready\n"
                    "a_normal:\n"
                    "    ORI   R25, 0x04         ; Para normal, adiciona bit implícito\n"
                    "a_ready:\n"
                    "    MOV   R26, R16          ; Mantissa baixa de B\n"
                    "    MOV   R27, R17          ; Mantissa alta de B\n"
                    "    ANDI  R27, 0x03\n"
                    "    CPI   R21, 0\n"
                    "    BRNE  b_normal\n"
                    "    LDI   R21, 1\n"
                    "    RJMP  b_ready\n"
                    "b_normal:\n"
                    "    ORI   R27, 0x04\n"
                    "b_ready:\n"
                    "\n"
                    "    ; Ajusta o expoente do resultado: exp_res = exp_A - exp_B + 15\n"
                    "    SUB   R20, R21\n"
                    "    SUBI  R20, 241          ; SUBI R20, -15 (2's complement de 15)\n"
                    "\n"
                    "    ; Prepara o dividendo (mantissa de A) para a divisão (alinhamento via shifts)\n"
                    "    CLR   R2                ; R2 será o byte mais alto\n"
                    "    MOV   R3, R25           ; Byte intermediário\n"
                    "    MOV   R4, R24           ; Byte baixo\n"
                    "    LDI   R16, 4\n"
                    "shift_dividend_prep:\n"
                    "    LSL   R4\n"
                    "    ROL   R3\n"
                    "    ROL   R2\n"
                    "    DEC   R16\n"
                    "    BRNE  shift_dividend_prep\n"
                    "\n"
                    "    LDI   R16, 8\n"
                    "shift_dividend_main:\n"
                    "    LSL   R4\n"
                    "    ROL   R3\n"
                    "    ROL   R2\n"
                    "    DEC   R16\n"
                    "    BRNE  shift_dividend_main\n"
                    "\n"
                    "    ; Inicializa o quociente (16 bits)\n"
                    "    CLR   R1\n"
                    "    CLR   R0\n"
                    "    LDI   R17, 16          ; Contador de iterações\n"
                    "\n"
                    "div_loop_restoring:\n"
                    "    ; Desloca o resto (R2:R3:R4) à esquerda\n"
                    "    LSL   R4\n"
                    "    ROL   R3\n"
                    "    ROL   R2\n"
                    "    ; Salva o resto atual antes da subtração\n"
                    "    MOV   R5, R2\n"
                    "    MOV   R6, R3\n"
                    "    ; Tenta subtrair o divisor (mantissa de B: R27:R26) do resto\n"
                    "    SUB   R2, R27\n"
                    "    SBC   R3, R26\n"
                    "    ; Desloca o quociente à esquerda e insere 0\n"
                    "    LSL   R0\n"
                    "    ROL   R1\n"
                    "    ; Se houve borrow (R < 0), restaura o resto\n"
                    "    BRCS  restore_remainder\n"
                    "    ; Se não houve borrow, seta o LSB do quociente\n"
                    "    LDI   R16, 0x01\n"
                    "    OR    R0, R16\n"
                    "    RJMP  div_iter_done_restoring\n"
                    "\n"
                    "restore_remainder:\n"
                    "    MOV   R2, R5           ; Restaura o resto\n"
                    "    MOV   R3, R6\n"
                    "\n"
                    "div_iter_done_restoring:\n"
                    "    DEC   R17\n"
                    "    BRNE  div_loop_restoring\n"
                    "\n"
                    "    ; --- Normalização do Quociente ---\n"
                    "    ; Se o quociente estiver \"grande\" demais, faz shift right para normalizar\n"
                    "    TST   R1\n"
                    "    BRMI  norm_shift_right   ; Se o bit de sinal (MSB) estiver 1, normaliza com shift right\n"
                    "    SBRS  R1, 4              ; Se bit 4 de R1 estiver setado, também precisa de shift right\n"
                    "    RJMP  norm_find_msb\n"
                    "\n"
                    "norm_shift_right:\n"
                    "    CLR   R7                ; Zera o sticky\n"
                    "    OR    R2, R3            ; Se resto ≠ 0, sticky = 1\n"
                    "    BRNE  set_sticky_s1\n"
                    "    TST   R0\n"
                    "    BRNE  set_sticky_s1\n"
                    "    RJMP  sticky_done_s1\n"
                    "set_sticky_s1:\n"
                    "    LDI   R16, 1\n"
                    "    OR    R7, R16           ; sticky_s1 = 1\n"
                    "sticky_done_s1:\n"
                    "    MOV   R16, R0           ; Guarda LSB como Guard (G)\n"
                    "    ANDI  R16, 0x01\n"
                    "    ; --- PRIMEIRO shift right lógico de 16 bits (quociente) ---\n"
                    "    LSR   R1               ; Desloca R1 com preenchimento zero\n"
                    "    ROR   R0               ; Desloca R0, trazendo o bit do carry\n"
                    "    ; Verifica se é necessário um segundo shift (caso bit 3 de R1 ainda esteja setado)\n"
                    "    SBRS  R1, 3\n"
                    "    RJMP  rounding_check\n"
                    "    ; --- SEGUNDO shift right ---\n"
                    "    OR    R7, R16          ; Atualiza sticky com o guard anterior\n"
                    "    MOV   R16, R0\n"
                    "    ANDI  R16, 0x01        ; Novo guard\n"
                    "    LSR   R1\n"
                    "    ROR   R0\n"
                    "    MOV   R6, R16          ; Guarda o guard final\n"
                    "    RJMP  rounding_check\n"
                    "\n"
                    "norm_find_msb:\n"
                    "    OR    R1, R0\n"
                    "    BRNE  norm_not_zero\n"
                    "    RJMP  pack_zero        ; Se quociente for zero, empacota como zero\n"
                    "norm_not_zero:\n"
                    "    LDI   R16, 0           ; Contador de deslocamentos (R16 = 0)\n"
                    "norm_shift_left_loop:\n"
                    "    SBRS  R1, 3            ; Verifica se o bit de posição 3 (posição normalizada) está setado\n"
                    "    RJMP  found_msb_pos\n"
                    "    LSL   R0\n"
                    "    ROL   R1\n"
                    "    INC   R16\n"
                    "    CPI   R16, 16\n"
                    "    BREQ  norm_done        ; Caso de segurança\n"
                    "    RJMP  norm_shift_left_loop\n"
                    "found_msb_pos:\n"
                    "    SUB   R20, R16         ; Ajusta o expoente conforme o número de shifts\n"
                    "    RJMP  norm_done\n"
                    "\n"
                    "rounding_check:\n"
                    "    TST   R6\n"
                    "    BREQ  norm_done        ; Se guard = 0, não arredonda\n"
                    "    TST   R7\n"
                    "    BRNE  round_up        ; Se sticky = 1, arredonda para cima\n"
                    "    SBRS  R0, 0\n"
                    "    RJMP  round_up\n"
                    "    RJMP  norm_done\n"
                    "\n"
                    "round_up:\n"
                    "    INC   R0              ; Incrementa o quociente para arredondar\n"
                    "    BRNE  skip_inc_r1\n"
                    "    INC   R1\n"
                    "skip_inc_r1:\n"
                    "    SBRS  R1, 3           ; Verifica se houve overflow na mantissa por arredondamento\n"
                    "    RJMP  norm_done\n"
                    "    INC   R20\n"
                    "\n"
                    "norm_done:\n"
                    "    ; --- Verificação de Overflow/Underflow do Expoente ---\n"
                    "check_exponent:\n"
                    "    CPI   R20, 31\n"
                    "    BRLO  exp_not_overflow\n"
                    "    RJMP  pack_infinity\n"
                    "exp_not_overflow:\n"
                    "    CPI   R20, 1\n"
                    "    BRLO  handle_underflow\n"
                    "    RJMP  pack_normal\n"
                    "\n"
                    "handle_underflow:\n"
                    "    MOV   R16, R20\n"
                    "    NEG   R16\n"
                    "    INC   R16\n"
                    "    CLR   R6\n"
                    "underflow_shift_loop:\n"
                    "    CPI   R16, 0\n"
                    "    BREQ  pack_denormal\n"
                    "    SEC\n"
                    "    SBRC  R0, 0\n"
                    "    CLC\n"
                    "    BRCC skip_set_sticky\n"
                    "    LDI   R17, 1\n"
                    "    OR    R6, R17\n"
                    "skip_set_sticky:\n"
                    "    LSR   R1\n"
                    "    ROR   R0\n"
                    "    DEC   R16\n"
                    "    RJMP  underflow_shift_loop\n"
                    "\n"
                    "pack_denormal:\n"
                    "    BRCS  denorm_guard_is_1\n"
                    "    RJMP  pack_denorm_final\n"
                    "denorm_guard_is_1:\n"
                    "    TST   R6\n"
                    "    BRNE  denorm_round_up\n"
                    "    SBRS  R0, 0\n"
                    "    RJMP  denorm_round_up\n"
                    "    RJMP  pack_denorm_final\n"
                    "denorm_round_up:\n"
                    "    INC   R0\n"
                    "    BRNE  skip_inc_r1_denorm\n"
                    "    INC   R1\n"
                    "skip_inc_r1_denorm:\n"
                    "    LDI   R16, 0x00\n"
                    "    CP    R0, R16\n"
                    "    BRNE  pack_denorm_final\n"
                    "    LDI   R16, 0x04\n"
                    "    CP    R1, R16\n"
                    "    BRNE  pack_denorm_final\n"
                    "    LDI   R20, 1\n"
                    "    RJMP  pack_normal\n"
                    "\n"
                    "pack_denorm_final:\n"
                    "    CLR   R20\n"
                    "    RJMP  pack_final\n"
                    "\n"
                    "pack_zero:\n"
                    "    ; Empacota zero com sinal preservado\n"
                    "    CLR   R22\n"
                    "    MOV   R23, R30\n"
                    "    RET\n"
                    "\n"
                    "pack_normal:\n"
                    "    ; Empacota número normalizado\n"
                    "    CLR   R22             ; Inicializa byte baixo do resultado\n"
                    "    ; Extrai M7 (Q8) de R1 e coloca no bit 7 de R22\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x01\n"
                    "    LSL   R16             ; Desloca 7 vezes para posicionar no bit 7\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    OR    R22, R16\n"
                    "    ; Extrai M6..M0 de R0 para os bits 6..0 de R22\n"
                    "    MOV   R16, R0\n"
                    "    LSR   R16             ; Q7..Q1 passam para bits 6..0 (Q0 é descartado)\n"
                    "    ANDI  R16, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    ; Prepara o byte alto do resultado (S:E4:E3:E2:E1:E0:M9:M8)\n"
                    "    MOV   R23, R30        ; Inicia com o sinal\n"
                    "    MOV   R16, R20\n"
                    "    LSL   R16             ; Desloca expoente 2 vezes\n"
                    "    LSL   R16\n"
                    "    ANDI  R16, 0x7C\n"
                    "    OR    R23, R16\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x06       ; Extrai M9 e M8 (bits 2 e 1 de R1)\n"
                    "    LSR   R16             ; Alinha para bits 1..0\n"
                    "    OR    R23, R16\n"
                    "    RET\n"
                    "\n"
                    "pack_final:\n"
                    "    ; Empacota o resultado para casos de underflow/denormal\n"
                    "    CLR   R22\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x01\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    OR    R22, R16\n"
                    "    MOV   R16, R0\n"
                    "    LSR   R16\n"
                    "    ANDI  R16, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    MOV   R23, R30\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x06\n"
                    "    LSR   R16\n"
                    "    OR    R23, R16\n"
                    "    RET\n"
                    "\n"
                    "result_nan_quietA:\n"
                    "    ; Retorna Quiet NaN baseado em A\n"
                    "    MOV   R22, R18\n"
                    "    MOV   R23, R19\n"
                    "    ORI   R23, 0x7C\n"
                    "    ORI   R23, 0x02\n"
                    "    RET\n"
                    "\n"
                    "result_nan_quietB:\n"
                    "    ; Retorna Quiet NaN baseado em B\n"
                    "    MOV   R22, R16\n"
                    "    MOV   R23, R17\n"
                    "    ORI   R23, 0x7C\n"
                    "    ORI   R23, 0x02\n"
                    "    RET\n"
                    "\n"
                    "result_nan:\n"
                    "    ; Retorna NaN genérico (0/0, Inf/Inf, etc.)\n"
                    "    LDI   R22, 0x01\n"
                    "    LDI   R23, 0x7E\n"
                    "    RET\n"
                    "\n"
                    "pack_infinity:\n"
                    "    ; Empacota Infinito (+/-) com o sinal preservado\n"
                    "    LDI   R22, 0x00\n"
                    "    LDI   R23, 0x7C\n"
                    "    OR    R23, R30\n"
                    "    RET\n\n");
}

void op_div_int_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_div_int_16bits:\n"
                    "   ; --- Extrair sinais ---\n"
                    "   MOV R30, R19       ; Salvar sinal do dividendo\n"
                    "   ANDI R30, 0x80\n"
                    "   MOV R31, R17       ; Salvar sinal do divisor\n"
                    "   ANDI R31, 0x80\n"
                    "   EOR R30, R31       ; R30 = Sinal do resultado (XOR dos sinais)\n"
                    "\n"
                    "; --- Primeiro, realizar divisão normal ---\n"
                    "   CALL op_div_16bits  ; Resultado da divisão FP em R23:R22\n"
                    "\n"
                    "; --- Agora extrair componentes do resultado da divisão ---\n"
                    "   ; R23 = S:E4:E3:E2:E1:E0:M9:M8\n"
                    "   ; R22 = M7:M6:M5:M4:M3:M2:M1:M0\n"
                    "   MOV R20, R23\n"
                    "   ANDI R20, 0x7C     ; Isolar bits do expoente enviesado\n"
                    "   LSR R20\n"
                    "   LSR R20            ; R20 = Expoente enviesado E (0-31)\n"
                    "\n"
                    "; --- Casos especiais: NaN, Infinito, Zero ---\n"
                    "   CPI R20, 0x1F      ; Verificar se expoente é máximo (NaN ou Infinito)\n"
                    "   BREQ return_result ; Se for NaN ou Infinito, retornar como está (truncar Inf é Inf)\n"
                    "\n"
                    "   ; Verificar se o resultado da divisão é Zero ou Subnormal\n"
                    "   MOV R21, R23       ; Copia R23 para R21\n"
                    "   ANDI R21, 0x7F     ; Ignora sinal em R21\n"
                    "   OR R21, R22        ; Combina Expoente+Mantissa (sem sinal)\n"
                    "   BRNE check_magnitude ; Se R21 != 0, o número não é zero. Pula.\n"
                    "   ; Se R21 == 0, o resultado é +0.0 ou -0.0. Truncar zero é zero.\n"
                    "   CLR R22            ; Garante que R22 seja 0\n"
                    "   MOV R23, R30       ; R23 = 0 ou 0x80 (dependendo do sinal calculado R30)\n"
                    "   RJMP return_result ; Retorna +/- 0.0\n"
                    "\n"
                    "check_magnitude:\n"
                    "; --- Para um número normal/subnormal não zero ---\n"
                    "   ; Calcular expoente não enviesado p = E - 15\n"
                    "   ; Nota: Se E=0 (subnormal), tratamos como p=1-15 = -14 para a lógica abaixo.\n"
                    "   MOV R21, R20       ; R21 = E (enviesado)\n"
                    "   SUBI R21, 15       ; R21 = p (não enviesado, pode ser negativo)\n"
                    "\n"
                    "; --- Se p < 0, o valor absoluto é < 1.0. Truncado é +/- 0.0 ---\n"
                    "   BRSH p_ge_zero     ; Pula se p >= 0 (Bit S está 0)\n"
                    "   ; p < 0:\n"
                    "   CLR R22            ; Mantissa = 0\n"
                    "   MOV R23, R30       ; R23 = Sinal (resultado +/- 0.0)\n"
                    "   RJMP return_result\n"
                    "\n"
                    "p_ge_zero:\n"
                    "; --- Se p >= 10, não há bits fracionários na representação. Retorna original ---\n"
                    "; (A mantissa só tem 10 bits explícitos)\n"
                    "   CPI R21, 10        ; Compara p com 10\n"
                    "   BRSH return_result ; Pula se p >= 10 (retorna R23:R22 como está)\n"
                    "\n"
                    "; --- Se 0 <= p < 10, precisamos zerar os 10-p bits menos significativos da mantissa ---\n"
                    "   ; R21 = p (0 a 9)\n"
                    "   ; Número de bits fracionários a zerar = 10 - p\n"
                    "   LDI R16, 10\n"
                    "   SUB R16, R21       ; R16 = num_frac_bits (1 a 10)\n"
                    "\n"
                    "   ; Copiar mantissa para registros temporários para mascarar\n"
                    "   ; R25 = M9:M8 (bits 1:0), R24 = M7:M0\n"
                    "   MOV R24, R22\n"
                    "   MOV R25, R23\n"
                    "   ANDI R25, 0x03     ; Isola M9, M8 em R25 (bits 1, 0)\n"
                    "\n"
                    "   ; Mascarar os 'num_frac_bits' (R16) LSBs de R25:R24\n"
                    "\n"
                    "   ; Quantos bits zerar em R24 (M7..M0)? Min(num_frac_bits, 8)\n"
                    "   MOV R17, R16       ; Copia num_frac_bits para R17\n"
                    "   CPI R17, 8\n"
                    "   BRSH mask_r24_full ; Se num_frac_bits >= 8, zera todos os 8 bits de R24\n"
                    "   ; Se num_frac_bits < 8, zera apenas os 'num_frac_bits' LSBs\n"
                    "   ; Cria máscara 0xFF << num_frac_bits em R17\n"
                    "   LDI R20, 0xFF      ; Reutiliza R20 como registrador de máscara temporário\n"
                    "mask_loop_r24:\n"
                    "   CPI R17, 0\n"
                    "   BREQ apply_mask_r24\n"
                    "   LSL R20            ; Shift 0 para a direita na máscara\n"
                    "   DEC R17\n"
                    "   RJMP mask_loop_r24\n"
                    "apply_mask_r24:\n"
                    "   AND R24, R20       ; Zera os bits LSBs de R24\n"
                    "   RJMP mask_r25_check ; Pula para verificar R25\n"
                    "\n"
                    "mask_r24_full:\n"
                    "   CLR R24            ; Zera todos os 8 bits de R24 (M7..M0)\n"
                    "   ; num_frac_bits é 8, 9 ou 10. Precisa ajustar R16 para indicar quantos bits zerar em R25\n"
                    "   SUBI R16, 8        ; R16 agora é 0, 1 ou 2 (bits a zerar em R25)\n"
                    "\n"
                    "mask_r25_check:\n"
                    "   ; R16 contém o número de bits a zerar em R25 (M9=bit1, M8=bit0)\n"
                    "   ; R16=0: não faz nada\n"
                    "   ; R16=1: zera M8 (bit 0)\n"
                    "   ; R16=2: zera M9 e M8 (bits 1, 0)\n"
                    "   CPI R16, 1\n"
                    "   BRLO combine_result ; Se R16 == 0, não precisa zerar nada em R25\n"
                    "   CPI R16, 2\n"
                    "   BRNE mask_r25_m8   ; Se R16 == 1, zera só M8\n"
                    "   ; R16 == 2: Zera M9 e M8\n"
                    "   CLR R25            ; Zera R25 (continha M9, M8)\n"
                    "   RJMP combine_result\n"
                    "mask_r25_m8:\n"
                    "   ; R16 == 1: Zera M8 (bit 0)\n"
                    "   ANDI R25, 0x02     ; Mantém M9 (bit 1), zera M8 (bit 0)\n"
                    "   ; Fall through to combine_result\n"
                    "\n"
                    "combine_result:\n"
                    "   ; Combina a mantissa truncada (R25:R24) com o Sinal+Expoente original\n"
                    "   MOV R22, R24       ; R22 final = M7..M0 truncado\n"
                    "   ; R23 final = S:E4..E0:M9:M8 (M9, M8 truncados)\n"
                    "   ANDI R23, 0xFC     ; Limpa os bits M9, M8 antigos de R23\n"
                    "   OR R23, R25        ; Combina com os bits M9, M8 truncados (em R25)\n"
                    "   ; O sinal e expoente em R23 já estão corretos\n"
                    "\n"
                    "return_result:\n"
                    "   RET             ; Resultado em R23:R22\n");
}

void op_rem_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_rem_16bits:\n"
                    "    ; Calcula o resto da divisão de ponto flutuante (half-precision)\n"
                    "    ; Entrada: Dividendo 'a' em R19:R18\n"
                    "    ;          Divisor 'b' em R17:R16\n"
                    "    ; Saída:   Resto 'r' em R23:R22 ( r = a - trunc(a/b) * b )\n"
                    "    ; Clobbers: R0-R7, R16-R31 (verifica uso nas subrotinas chamadas)\n"
                    "    ; Preserva: Nada garantido exceto SP relativo entrada/saída.\n"
                    "\n"
                    "    ; --- 1. Salvar operandos originais na pilha ---\n"
                    "    PUSH R19 ; Salva a_high\n"
                    "    PUSH R18 ; Salva a_low\n"
                    "    PUSH R17 ; Salva b_high\n"
                    "    PUSH R16 ; Salva b_low\n"
                    "    ; Stack: [b_low] [b_high] [a_low] [a_high] <- SP\n"
                    "\n"
                    "    ; --- Salvar ponteiro da pilha (SP) em Z (R31:R30) para acesso ---\n"
                    "    ; O SP aponta para o último byte empilhado (b_low).\n"
                    "    ; Usaremos LDD com deslocamento a partir de Z para ler os valores originais.\n"
                    "    IN R30, SPL   ; ZL = SPL\n"
                    "    IN R31, SPH   ; ZH = SPH\n"
                    "    ; Layout na memória (endereços menores para maiores):\n"
                    "    ; SP   -> b_low  (Z+1)\n"
                    "    ; SP+1 -> b_high (Z+2)\n"
                    "    ; SP+2 -> a_low  (Z+3)\n"
                    "    ; SP+3 -> a_high (Z+4)\n"
                    "\n"
                    "    ; --- 2. Calcular q_trunc = trunc(a / b) ---\n"
                    "    ; op_div_int_16bits precisa de 'a' em R19:R18 e 'b' em R17:R16.\n"
                    "    ; Carregar 'b' original da pilha para R17:R16\n"
                    "    LDD R16, Z+1  ; b_low\n"
                    "    LDD R17, Z+2  ; b_high\n"
                    "    ; Carregar 'a' original da pilha para R19:R18\n"
                    "    LDD R18, Z+3  ; a_low\n"
                    "    LDD R19, Z+4  ; a_high\n"
                    "\n"
                    "    CALL op_div_int_16bits  ; Resultado q_trunc em R23:R22\n"
                    "\n"
                    "    ; --- 3. Calcular produto = q_trunc * b ---\n"
                    "    ; Mover q_trunc (R23:R22) para Op1 (R19:R18)\n"
                    "    MOV R19, R23\n"
                    "    MOV R18, R22\n"
                    "    ; Carregar 'b' original da pilha para Op2 (R17:R16)\n"
                    "    LDD R16, Z+1  ; b_low\n"
                    "    LDD R17, Z+2  ; b_high\n"
                    "\n"
                    "    CALL op_mult_16bits     ; Resultado produto (q_trunc * b) em R23:R22\n"
                    "\n"
                    "    ; --- 4. Calcular resto = a - produto ---\n"
                    "    ; Mover produto (R23:R22) para Op2 (R17:R16) para subtração\n"
                    "    MOV R17, R23\n"
                    "    MOV R16, R22\n"
                    "    ; Carregar 'a' original da pilha para Op1 (R19:R18)\n"
                    "    LDD R18, Z+3  ; a_low\n"
                    "    LDD R19, Z+4  ; a_high\n"
                    "\n"
                    "    CALL op_sub_16bits      ; Resultado final resto (a - produto) em R23:R22\n"
                    "\n"
                    "    ; --- 5. Limpar a pilha e retornar ---\n"
                    "    ; O resultado já está em R23:R22.\n"
                    "    ; Apenas desempilhar os 4 bytes salvos.\n"
                    "    POP R16 ; Descarta b_low\n"
                    "    POP R17 ; Descarta b_high\n"
                    "    POP R18 ; Descarta a_low\n"
                    "    POP R19 ; Descarta a_high\n"
                    "\n"
                    "    RET\n\n");
}

void op_power(FILE *outAsm) {
    fprintf(outAsm, "op_pow_16bits:\n"
                    "    ; Calcula base^n para float16 'base' e int8 'n'\n"
                    "    ; Entrada: base (R19:R18), n (R16)\n"
                    "    ; Saída: resultado (R23:R22)\n"
                    "    ; Clobbers: R16, R17, R19:R18, R23:R22, R24:R25, R26:R27, e outros usados por op_mult/op_div\n"
                    "\n"
                    "    ; --- Tratar n = 0 ---\n"
                    "    TST R16\n"
                    "    BRNE n_is_not_zero_pow\n"
                    "    ; n == 0. Resultado é 1.0 (0x3C00)\n"
                    "    LDI R23, 0x3C\n"
                    "    LDI R22, 0x00\n"
                    "    RET\n"
                    "n_is_not_zero_pow:\n"
                    "\n"
                    "    ; --- Tratar n = 1 ---\n"
                    "    CPI R16, 1\n"
                    "    BRNE n_is_not_one_pow\n"
                    "    ; n == 1. Resultado é 'base'.\n"
                    "    MOV R23, R19\n"
                    "    MOV R22, R18\n"
                    "    RET\n"
                    "n_is_not_one_pow:\n"
                    "\n"
                    "    ; === ATENÇÃO: Faltam tratamentos para bases especiais ===\n"
                    "    ; TODO: Adicionar verificações para base = NaN, +/-Inf, +/-0, +1, -1\n"
                    "    ;       O comportamento exato dependerá da definição desejada (ex: pow(0, -2) = Inf)\n"
                    "\n"
                    "    ; --- Tratar n < 0 ---\n"
                    "    SBRS R16, 7           ; Testar bit de sinal de n (bit 7)\n"
                    "    RJMP n_is_positive_pow ; Pular se n for positivo\n"
                    "\n"
                    "    ; n é negativo\n"
                    "    ; Calcular 1.0 / (base ^ abs(n))\n"
                    "\n"
                    "    ; TODO: Verificar se base == 0. Se sim, retornar +/- Infinito\n"
                    "    ;       (precisa de lógica de verificação de zero e empacotamento de Inf)\n"
                    "\n"
                    "    PUSH R19 ; Salvar base original\n"
                    "    PUSH R18\n"
                    "    PUSH R16 ; Salvar n original\n"
                    "\n"
                    "    NEG R16  ; n = abs(n) (assume 2's complement para R16)\n"
                    "\n"
                    "    ; Chama a rotina de exponenciação positiva\n"
                    "    RCALL pow_pos_exp_loop ; Calcula base^abs(n), resultado em R23:R22\n"
                    "\n"
                    "    ; Agora calcula 1.0 / resultado\n"
                    "    ; Mover resultado para divisor (R17:R16)\n"
                    "    MOV R17, R23\n"
                    "    MOV R16, R22\n"
                    "    ; Carregar 1.0 no dividendo (R19:R18)\n"
                    "    LDI R19, 0x3C\n"
                    "    LDI R18, 0x00\n"
                    "\n"
                    "    CALL op_div_16bits ; Resultado final em R23:R22\n"
                    "\n"
                    "    POP R16 ; Limpar pilha\n"
                    "    POP R18\n"
                    "    POP R19\n"
                    "    RET\n"
                    "\n"
                    "n_is_positive_pow:\n"
                    "    ; n é positivo (e maior que 1)\n"
                    "    ; Salvar registradores se necessário antes de chamar sub-rotina\n"
                    "    ; RCALL já salva PC, não precisamos salvar/restaurar n (R16) e base (R19:R18) aqui\n"
                    "    ; porque pow_pos_exp_loop os usa como entrada.\n"
                    "\n"
                    "    RCALL pow_pos_exp_loop ; Calcula base^n, resultado em R23:R22\n"
                    "    RET\n"
                    "\n"
                    "; ---------------------------------------------------------------------------\n"
                    "; Sub-rotina: Potenciação por Quadratura para Expoente Positivo\n"
                    "; Entrada: base (R19:R18), n (R16, n > 0)\n"
                    "; Saída: base^n (R23:R22)\n"
                    "; Usa: R24:R25 (power), R26:R27 (result_accum)\n"
                    "; Clobbers: R16, R17, R23:R22 (resultado mult), R24:R25, R26:R27\n"
                    ";           Assume que op_mult_16bits usa R19:R18, R17:R16 como input\n"
                    ";           e retorna resultado em R23:R22, clobbering others.\n"
                    "; ---------------------------------------------------------------------------\n"
                    "pow_pos_exp_loop:\n"
                    "    ; power = base\n"
                    "    MOV R24, R19\n"
                    "    MOV R25, R18\n"
                    "    ; result_accum = 1.0\n"
                    "    LDI R26, 0x3C\n"
                    "    LDI R27, 0x00\n"
                    "\n"
                    "pow_loop:\n"
                    "    TST R16                ; n == 0?\n"
                    "    BREQ pow_loop_end      ; Fim do loop\n"
                    "\n"
                    "    ; Se LSB de n é 1, result_accum = result_accum * power\n"
                    "    SBRC R16, 0            ; Pular chamada se bit 0 de n for 0\n"
                    "    RCALL multiply_result_by_power\n"
                    "\n"
                    "    ; power = power * power\n"
                    "    RCALL square_power\n"
                    "\n"
                    "    ; n = n >> 1 (deslocamento lógico à direita)\n"
                    "    LSR R16\n"
                    "\n"
                    "    RJMP pow_loop\n"
                    "\n"
                    "pow_loop_end:\n"
                    "    ; Resultado final está em result_accum (R26:R27)\n"
                    "    MOV R23, R26\n"
                    "    MOV R22, R27\n"
                    "    RET\n"
                    "\n"
                    "; --- Sub-rotina auxiliar para result_accum *= power ---\n"
                    "multiply_result_by_power:\n"
                    "    ; Prepara operandos para op_mult_16bits\n"
                    "    ; Op1 = result_accum (R26:R27)\n"
                    "    MOV R19, R26\n"
                    "    MOV R18, R27\n"
                    "    ; Op2 = power (R24:R25)\n"
                    "    MOV R17, R24\n"
                    "    MOV R16, R25\n"
                    "    CALL op_mult_16bits\n"
                    "    ; Atualiza result_accum com o resultado (R23:R22)\n"
                    "    MOV R26, R23\n"
                    "    MOV R27, R22\n"
                    "    RET\n"
                    "\n"
                    "; --- Sub-rotina auxiliar para power *= power ---\n"
                    "square_power:\n"
                    "    ; Prepara operandos para op_mult_16bits\n"
                    "    ; Op1 = power (R24:R25)\n"
                    "    MOV R19, R24\n"
                    "    MOV R18, R25\n"
                    "    ; Op2 = power (R24:R25)\n"
                    "    MOV R17, R24\n"
                    "    MOV R16, R25\n"
                    "    CALL op_mult_16bits\n"
                    "    ; Atualiza power com o resultado (R23:R22)\n"
                    "    MOV R24, R23\n"
                    "    MOV R25, R22\n"
                    "    RET\n\n");
}