//
// Created by Rafael Venetikides on 03/04/25.
//

#include "../../include/operations/rem_operation.h"

void op_rem_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_rem_16bits:\n"
                    "    ; Calcula o resto da divisão de ponto flutuante (half-precision)\n"
                    "    ; Entrada: Dividendo 'a' em R19:R18\n"
                    "    ;          Divisor 'b' em R17:R16\n"
                    "    ; Saída:   Resto 'r' em R23:R22 ( r = a - trunc(a/b) * b )\n"
                    "    ; Clobbers: R0-R7, R16-R31 (verifica uso nas subrotinas chamadas)\n"
                    "    ; Preserva: Nada garantido exceto SP relativo entrada/saída.\n"
                    "\n"
                    "    ; --- 1. Salvar operandos originais na pilha ---\n"
                    "    PUSH R19 ; Salva a_high\n"
                    "    PUSH R18 ; Salva a_low\n"
                    "    PUSH R17 ; Salva b_high\n"
                    "    PUSH R16 ; Salva b_low\n"
                    "    ; Stack: [b_low] [b_high] [a_low] [a_high] <- SP\n"
                    "\n"
                    "    ; --- Salvar ponteiro da pilha (SP) em Z (R31:R30) para acesso ---\n"
                    "    ; O SP aponta para o último byte empilhado (b_low).\n"
                    "    ; Usaremos LDD com deslocamento a partir de Z para ler os valores originais.\n"
                    "    IN R30, SPL   ; ZL = SPL\n"
                    "    IN R31, SPH   ; ZH = SPH\n"
                    "    ; Layout na memória (endereços menores para maiores):\n"
                    "    ; SP   -> b_low  (Z+1)\n"
                    "    ; SP+1 -> b_high (Z+2)\n"
                    "    ; SP+2 -> a_low  (Z+3)\n"
                    "    ; SP+3 -> a_high (Z+4)\n"
                    "\n"
                    "    ; --- 2. Calcular q_trunc = trunc(a / b) ---\n"
                    "    ; op_div_int_16bits precisa de 'a' em R19:R18 e 'b' em R17:R16.\n"
                    "    ; Carregar 'b' original da pilha para R17:R16\n"
                    "    LDD R16, Z+1  ; b_low\n"
                    "    LDD R17, Z+2  ; b_high\n"
                    "    ; Carregar 'a' original da pilha para R19:R18\n"
                    "    LDD R18, Z+3  ; a_low\n"
                    "    LDD R19, Z+4  ; a_high\n"
                    "\n"
                    "    CALL op_div_int_16bits  ; Resultado q_trunc em R23:R22\n"
                    "\n"
                    "    ; --- 3. Calcular produto = q_trunc * b ---\n"
                    "    ; Mover q_trunc (R23:R22) para Op1 (R19:R18)\n"
                    "    MOV R19, R23\n"
                    "    MOV R18, R22\n"
                    "    ; Carregar 'b' original da pilha para Op2 (R17:R16)\n"
                    "    LDD R16, Z+1  ; b_low\n"
                    "    LDD R17, Z+2  ; b_high\n"
                    "\n"
                    "    CALL op_mult_16bits\n"
                    "\n"
                    "    ; --- 4. Calcular resto = a - produto ---\n"
                    "    MOV R17, R23\n"
                    "    MOV R16, R22\n"
                    "    LDD R18, Z+3\n"
                    "    LDD R19, Z+4\n"
                    "\n"
                    "    CALL op_sub_16bits\n"
                    "\n"
                    "    POP R16\n"
                    "    POP R17\n"
                    "    POP R18\n"
                    "    POP R19\n"
                    "\n"
                    "    RET\n\n");
}