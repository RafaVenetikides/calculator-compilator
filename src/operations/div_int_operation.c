//
// Created by Rafael Venetikides on 03/04/25.
//

#include "../../include/operations/div_int_operation.h"


void op_div_int_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_div_int_16bits:\n"
                    "   ; --- Extrair sinais ---\n"
                    "   MOV R30, R19       ; Salvar sinal do dividendo\n"
                    "   ANDI R30, 0x80\n"
                    "   MOV R31, R17       ; Salvar sinal do divisor\n"
                    "   ANDI R31, 0x80\n"
                    "   EOR R30, R31       ; R30 = Sinal do resultado (XOR dos sinais)\n"
                    "\n"
                    "; --- Primeiro, realizar divisão normal ---\n"
                    "   CALL op_div_16bits  ; Resultado da divisão FP em R23:R22\n"
                    "\n"
                    "; --- Agora extrair componentes do resultado da divisão ---\n"
                    "   ; R23 = S:E4:E3:E2:E1:E0:M9:M8\n"
                    "   ; R22 = M7:M6:M5:M4:M3:M2:M1:M0\n"
                    "   MOV R20, R23\n"
                    "   ANDI R20, 0x7C     ; Isolar bits do expoente enviesado\n"
                    "   LSR R20\n"
                    "   LSR R20            ; R20 = Expoente enviesado E (0-31)\n"
                    "\n"
                    "; --- Casos especiais: NaN, Infinito, Zero ---\n"
                    "   CPI R20, 0x1F      ; Verificar se expoente é máximo (NaN ou Infinito)\n"
                    "   BREQ return_result ; Se for NaN ou Infinito, retornar como está (truncar Inf é Inf)\n"
                    "\n"
                    "   ; Verificar se o resultado da divisão é Zero ou Subnormal\n"
                    "   MOV R21, R23       ; Copia R23 para R21\n"
                    "   ANDI R21, 0x7F     ; Ignora sinal em R21\n"
                    "   OR R21, R22        ; Combina Expoente+Mantissa (sem sinal)\n"
                    "   BRNE check_magnitude ; Se R21 != 0, o número não é zero. Pula.\n"
                    "   ; Se R21 == 0, o resultado é +0.0 ou -0.0. Truncar zero é zero.\n"
                    "   CLR R22            ; Garante que R22 seja 0\n"
                    "   MOV R23, R30       ; R23 = 0 ou 0x80 (dependendo do sinal calculado R30)\n"
                    "   RJMP return_result ; Retorna +/- 0.0\n"
                    "\n"
                    "check_magnitude:\n"
                    "; --- Para um número normal/subnormal não zero ---\n"
                    "   ; Calcular expoente não enviesado p = E - 15\n"
                    "   ; Nota: Se E=0 (subnormal), tratamos como p=1-15 = -14 para a lógica abaixo.\n"
                    "   MOV R21, R20       ; R21 = E (enviesado)\n"
                    "   SUBI R21, 15       ; R21 = p (não enviesado, pode ser negativo)\n"
                    "\n"
                    "; --- Se p < 0, o valor absoluto é < 1.0. Truncado é +/- 0.0 ---\n"
                    "   BRSH p_ge_zero     ; Pula se p >= 0 (Bit S está 0)\n"
                    "   ; p < 0:\n"
                    "   CLR R22            ; Mantissa = 0\n"
                    "   MOV R23, R30       ; R23 = Sinal (resultado +/- 0.0)\n"
                    "   RJMP return_result\n"
                    "\n"
                    "p_ge_zero:\n"
                    "; --- Se p >= 10, não há bits fracionários na representação. Retorna original ---\n"
                    "; (A mantissa só tem 10 bits explícitos)\n"
                    "   CPI R21, 10        ; Compara p com 10\n"
                    "   BRSH return_result ; Pula se p >= 10 (retorna R23:R22 como está)\n"
                    "\n"
                    "; --- Se 0 <= p < 10, precisamos zerar os 10-p bits menos significativos da mantissa ---\n"
                    "   ; R21 = p (0 a 9)\n"
                    "   ; Número de bits fracionários a zerar = 10 - p\n"
                    "   LDI R16, 10\n"
                    "   SUB R16, R21       ; R16 = num_frac_bits (1 a 10)\n"
                    "\n"
                    "   ; Copiar mantissa para registros temporários para mascarar\n"
                    "   ; R25 = M9:M8 (bits 1:0), R24 = M7:M0\n"
                    "   MOV R24, R22\n"
                    "   MOV R25, R23\n"
                    "   ANDI R25, 0x03     ; Isola M9, M8 em R25 (bits 1, 0)\n"
                    "\n"
                    "   ; Mascarar os 'num_frac_bits' (R16) LSBs de R25:R24\n"
                    "\n"
                    "   ; Quantos bits zerar em R24 (M7..M0)? Min(num_frac_bits, 8)\n"
                    "   MOV R17, R16       ; Copia num_frac_bits para R17\n"
                    "   CPI R17, 8\n"
                    "   BRSH mask_r24_full ; Se num_frac_bits >= 8, zera todos os 8 bits de R24\n"
                    "   ; Se num_frac_bits < 8, zera apenas os 'num_frac_bits' LSBs\n"
                    "   ; Cria máscara 0xFF << num_frac_bits em R17\n"
                    "   LDI R20, 0xFF      ; Reutiliza R20 como registrador de máscara temporário\n"
                    "mask_loop_r24:\n"
                    "   CPI R17, 0\n"
                    "   BREQ apply_mask_r24\n"
                    "   LSL R20            ; Shift 0 para a direita na máscara\n"
                    "   DEC R17\n"
                    "   RJMP mask_loop_r24\n"
                    "apply_mask_r24:\n"
                    "   AND R24, R20       ; Zera os bits LSBs de R24\n"
                    "   RJMP mask_r25_check ; Pula para verificar R25\n"
                    "\n"
                    "mask_r24_full:\n"
                    "   CLR R24            ; Zera todos os 8 bits de R24 (M7..M0)\n"
                    "   ; num_frac_bits é 8, 9 ou 10. Precisa ajustar R16 para indicar quantos bits zerar em R25\n"
                    "   SUBI R16, 8        ; R16 agora é 0, 1 ou 2 (bits a zerar em R25)\n"
                    "\n"
                    "mask_r25_check:\n"
                    "   ; R16 contém o número de bits a zerar em R25 (M9=bit1, M8=bit0)\n"
                    "   ; R16=0: não faz nada\n"
                    "   ; R16=1: zera M8 (bit 0)\n"
                    "   ; R16=2: zera M9 e M8 (bits 1, 0)\n"
                    "   CPI R16, 1\n"
                    "   BRLO combine_result ; Se R16 == 0, não precisa zerar nada em R25\n"
                    "   CPI R16, 2\n"
                    "   BRNE mask_r25_m8   ; Se R16 == 1, zera só M8\n"
                    "   ; R16 == 2: Zera M9 e M8\n"
                    "   CLR R25            ; Zera R25 (continha M9, M8)\n"
                    "   RJMP combine_result\n"
                    "mask_r25_m8:\n"
                    "   ; R16 == 1: Zera M8 (bit 0)\n"
                    "   ANDI R25, 0x02     ; Mantém M9 (bit 1), zera M8 (bit 0)\n"
                    "   ; Fall through to combine_result\n"
                    "\n"
                    "combine_result:\n"
                    "   ; Combina a mantissa truncada (R25:R24) com o Sinal+Expoente original\n"
                    "   MOV R22, R24       ; R22 final = M7..M0 truncado\n"
                    "   ; R23 final = S:E4..E0:M9:M8 (M9, M8 truncados)\n"
                    "   ANDI R23, 0xFC     ; Limpa os bits M9, M8 antigos de R23\n"
                    "   OR R23, R25        ; Combina com os bits M9, M8 truncados (em R25)\n"
                    "   ; O sinal e expoente em R23 já estão corretos\n"
                    "\n"
                    "return_result:\n"
                    "   RET             ; Resultado em R23:R22\n");
}
