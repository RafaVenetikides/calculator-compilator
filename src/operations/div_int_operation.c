//
// Created by Rafael Venetikides on 03/04/25.
//

#include "../../include/operations/div_int_operation.h"


void op_div_int_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_div_int_16bits:\n"
                    "    ; Inicializa o contador com 0.0 (float16: 0x0000)\n"
                    "    CLR   R15         ; Contador high = 0\n"
                    "    CLR   R14         ; Contador low  = 0\n"
                    "\n"
                    "div_loop_int:\n"
                    "    ; Verifica se A (R19:R18) >= B (R17:R16)\n"
                    "    CP    R16, R18     ; Compara bytes baixos\n"
                    "    CPC   R17, R19     ; Compara bytes altos com carry\n"
                    "    BRLO  end_div_int  ; Se A < B, termina\n"
                    "\n"
                    "    ; --- Copiar A para registradores de entrada da subtração ---\n"
                    "    MOV   R20, R19     ; A_high → R20\n"
                    "    MOV   R21, R18     ; A_low  → R21\n"
                    "    ; Copiar B para registradores de entrada da subtração\n"
                    "    MOV   R22, R17     ; B_high → R22\n"
                    "    MOV   R23, R16     ; B_low  → R23\n"
                    "\n"
                    "    ; --- Preparar os operandos para op_sub_16bits ---\n"
                    "    MOV   R19, R20     ; A_high\n"
                    "    MOV   R18, R21     ; A_low\n"
                    "    MOV   R17, R22     ; B_high\n"
                    "    MOV   R16, R23     ; B_low\n"
                    "    CALL  op_sub_16bits ; Resultado em R23:R22 (A - B)\n"
                    "\n"
                    "    ; Atualiza A com o resultado da subtração\n"
                    "    MOV   R17, R23     ; A = A - B (high)\n"
                    "    MOV   R16, R22     ; A = A - B (low)\n"
                    "    PUSH R19\n"
                    "    PUSH R18\n"
                    "    PUSH R17\n"
                    "    PUSH R16\n"
                    "\n"
                    "    ; Incrementa o contador em 1.0 (float16: 0x3C00)\n"
                    "    ; Usa op_add_16bits: contador está em R15:R14\n"
                    "    MOV   R19, R15     ; contador high\n"
                    "    MOV   R18, R14     ; contador low\n"
                    "    LDI   R17, 0x3C     ; 1.0 high byte\n"
                    "    LDI   R16, 0x00     ; 1.0 low byte\n"
                    "    CALL  op_add_16bits ; Resultado em R23:R22\n"
                    "\n"
                    "    ; Atualiza o contador\n"
                    "    MOV   R15, R23\n"
                    "    MOV   R14, R22\n"
                    "    POP R16\n"
                    "    POP R17\n"
                    "    POP R18\n"
                    "    POP R19\n"
                    "\n"
                    "    RJMP  div_loop_int\n"
                    "\n"
                    "end_div_int:\n"
                    "    ; Quando A < B, o contador (R15:R14) contém o quociente\n"
                    "    MOV   R23, R15\n"
                    "    MOV   R22, R14\n"
                    "    RET\n\n");
}
