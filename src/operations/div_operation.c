//
// Created by Rafael Venetikides on 03/04/25.
//

#include "../../include/operations/div_operation.h"


void op_div_16bits(FILE *outAsm) {
    fprintf(outAsm, "op_div_16bits:\n"
                    "    ; --- Tratamento do Sinal ---\n"
                    "    MOV   R30, R19\n"
                    "    ANDI  R30, 0x80         ; Sinal de A\n"
                    "    MOV   R31, R17\n"
                    "    ANDI  R31, 0x80         ; Sinal de B\n"
                    "    EOR   R30, R31          ; R30 = Sinal do Resultado (0x80 ou 0x00)\n"
                    "\n"
                    "    ; --- Tratamento de Casos Especiais ---\n"
                    "    ; Verifica se A é NaN ou Infinito\n"
                    "    MOV   R20, R19          ; R20 = A_high\n"
                    "    ANDI  R20, 0x7C         ; Isola o expoente de A\n"
                    "    CPI   R20, 0x7C         ; Expoente = 0x1F?\n"
                    "    BREQ  is_exp_1f_A\n"
                    "    RJMP  check_b_nan_inf\n"
                    "is_exp_1f_A:\n"
                    "    ; A possui expoente 0x1F (Inf ou NaN)\n"
                    "    MOV   R21, R19          ; Verifica a mantissa de A\n"
                    "    ANDI  R21, 0x03\n"
                    "    OR    R21, R18          ; R21 = mantissa baixa | bits altos da mantissa\n"
                    "    BREQ  a_is_inf_check    ; If equal (mantissa is 0), branch locally (A is Inf)\n"
                    "    RJMP  result_nan_quietA ; If not equal (original condition), jump far (A is NaN)\n"
                    "a_is_inf_check:\n"
                    "\n"
                    "    ; A é Infinito\n"
                    "    MOV   R22, R17          ; R22 = B_high\n"
                    "    ANDI  R22, 0x7C         ; Isola expoente de B\n"
                    "    CPI   R22, 0x7C         ; B também 0x1F?\n"
                    "    BREQ  is_exp_1f_B\n"
                    "    RJMP  pack_infinity\n"
                    "is_exp_1f_B:\n"
                    "    ; B também é Inf/NaN\n"
                    "    MOV   R23, R17          ; Verifica mantissa de B\n"
                    "    ANDI  R23, 0x03\n"
                    "    OR    R23, R16          ; R23 = mantissa de B\n"
                    "    BREQ  b_is_inf          ; If equal (mantissa is 0), branch locally\n"
                    "    RJMP  result_nan_quietB ; If not equal (original condition), jump far (B is NaN)\n"
                    "b_is_inf:\n"
                    "    ; Ambos Inf →  Inf/Inf = Indeterminado → NaN\n"
                    "    RJMP  result_nan\n"
                    "\n"
                    "check_b_nan_inf:\n"
                    "    ; Verifica se B é NaN ou Infinito\n"
                    "    MOV   R22, R17\n"
                    "    ANDI  R22, 0x7C\n"
                    "    CPI   R22, 0x7C\n"
                    "    BREQ  b_is_nan_or_inf ; If equal, branch locally to handle NaN/Inf\n"
                    "    RJMP  check_a_zero    ; If not equal (original condition), jump far\n"
                    "b_is_nan_or_inf:\n"
                    "    ; This is the code that originally followed the BRNE\n"
                    "    MOV   R23, R17\n"
                    "    ANDI  R23, 0x03\n"
                    "    OR    R23, R16\n"
                    "    ; --- Make sure the fix for BRNE result_nan_quietB is still here ---\n"
                    "    ; Example: Assuming that fix was applied and worked:\n"
                    "    BREQ b_is_inf_check2  ; If equal (mantissa 0 -> B is Inf), branch locally\n"
                    "    RJMP result_nan_quietB ; If not equal (mantissa non-zero -> B is NaN)\n"
                    "b_is_inf_check2:\n"
                    "    ; B is Infinito e A é finito → resultado zero\n"
                    "    CLR   R22             ; Resultado baixa = 0\n"
                    "    MOV   R23, R30        ; Resultado alta = Sinal\n"
                    "    RET\n"
                    "\n"
                    "check_a_zero:\n"
                    "    ; Verifica se A é zero (expoente e mantissa 0)\n"
                    "    MOV   R20, R19\n"
                    "    ANDI  R20, 0x7F         ; Ignora sinal\n"
                    "    OR    R20, R18\n"
                    "    BREQ  a_is_zero_check   ; If equal (A is 0), branch locally\n"
                    "    RJMP  check_b_zero      ; If not equal (original condition), jump far (A is not 0)\n"
                    "a_is_zero_check:\n"
                    "    ; A = zero\n"
                    "    MOV   R22, R17          ; Verifica se B é zero\n"
                    "    ANDI  R22, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    BREQ  b_is_also_zero    ; If equal (B is 0), branch locally (handle 0/0)\n"
                    "    RJMP  div_a_is_zero     ; If not equal (original condition), jump far (B != 0, result is 0)\n"
                    "b_is_also_zero:\n"
                    "    RJMP  result_nan        ; 0/0 → NaN\n"
                    "\n"
                    "div_a_is_zero:\n"
                    "    CLR   R22               ; Resultado baixa = 0\n"
                    "    MOV   R23, R30          ; Resultado alta = Sinal\n"
                    "    RET\n"
                    "\n"
                    "check_b_zero:\n"
                    "    ; Verifica se B é zero\n"
                    "    MOV   R22, R17\n"
                    "    ANDI  R22, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    BRNE  continue_division  ; Se B ≠ 0, prossegue com a divisão\n"
                    "    ; Divisão por zero → Infinito\n"
                    "    LDI   R22, 0x00         ; Mantissa = 0\n"
                    "    LDI   R23, 0x7C         ; Expoente = 0x1F\n"
                    "    OR    R23, R30          ; Adiciona sinal\n"
                    "    RET\n"
                    "\n"
                    "; --- Divisão Normal ---\n"
                    "continue_division:\n"
                    "    ; Extrai os Expoentes\n"
                    "    MOV   R20, R19\n"
                    "    ANDI  R20, 0x7C         ; Expoente de A\n"
                    "    LSR   R20\n"
                    "    LSR   R20               ; Expoente A (viés) [0..31]\n"
                    "    MOV   R21, R17\n"
                    "    ANDI  R21, 0x7C         ; Expoente de B\n"
                    "    LSR   R21\n"
                    "    LSR   R21               ; Expoente B\n"
                    "\n"
                    "    ; Extrai as Mantissas e adiciona o bit implícito\n"
                    "    MOV   R24, R18          ; Mantissa baixa de A\n"
                    "    MOV   R25, R19          ; Mantissa alta de A\n"
                    "    ANDI  R25, 0x03         ; Remove bits de expoente/sinal\n"
                    "    CPI   R20, 0            ; Verifica se A é denormal\n"
                    "    BRNE  a_normal\n"
                    "    LDI   R20, 1            ; Para denormal, expoente efetivo = 1 (sem bit implícito)\n"
                    "    RJMP  a_ready\n"
                    "a_normal:\n"
                    "    ORI   R25, 0x04         ; Para normal, adiciona bit implícito\n"
                    "a_ready:\n"
                    "    MOV   R26, R16          ; Mantissa baixa de B\n"
                    "    MOV   R27, R17          ; Mantissa alta de B\n"
                    "    ANDI  R27, 0x03\n"
                    "    CPI   R21, 0\n"
                    "    BRNE  b_normal\n"
                    "    LDI   R21, 1\n"
                    "    RJMP  b_ready\n"
                    "b_normal:\n"
                    "    ORI   R27, 0x04\n"
                    "b_ready:\n"
                    "\n"
                    "    ; Ajusta o expoente do resultado: exp_res = exp_A - exp_B + 15\n"
                    "    SUB   R20, R21\n"
                    "    SUBI  R20, 241          ; SUBI R20, -15 (2's complement de 15)\n"
                    "\n"
                    "    ; Prepara o dividendo (mantissa de A) para a divisão (alinhamento via shifts)\n"
                    "    CLR   R2                ; R2 será o byte mais alto\n"
                    "    MOV   R3, R25           ; Byte intermediário\n"
                    "    MOV   R4, R24           ; Byte baixo\n"
                    "    LDI   R16, 4\n"
                    "shift_dividend_prep:\n"
                    "    LSL   R4\n"
                    "    ROL   R3\n"
                    "    ROL   R2\n"
                    "    DEC   R16\n"
                    "    BRNE  shift_dividend_prep\n"
                    "\n"
                    "    LDI   R16, 8\n"
                    "shift_dividend_main:\n"
                    "    LSL   R4\n"
                    "    ROL   R3\n"
                    "    ROL   R2\n"
                    "    DEC   R16\n"
                    "    BRNE  shift_dividend_main\n"
                    "\n"
                    "    ; Inicializa o quociente (16 bits)\n"
                    "    CLR   R1\n"
                    "    CLR   R0\n"
                    "    LDI   R17, 16          ; Contador de iterações\n"
                    "\n"
                    "div_loop_restoring:\n"
                    "    ; Desloca o resto (R2:R3:R4) à esquerda\n"
                    "    LSL   R4\n"
                    "    ROL   R3\n"
                    "    ROL   R2\n"
                    "    ; Salva o resto atual antes da subtração\n"
                    "    MOV   R5, R2\n"
                    "    MOV   R6, R3\n"
                    "    ; Tenta subtrair o divisor (mantissa de B: R27:R26) do resto\n"
                    "    SUB   R2, R27\n"
                    "    SBC   R3, R26\n"
                    "    ; Desloca o quociente à esquerda e insere 0\n"
                    "    LSL   R0\n"
                    "    ROL   R1\n"
                    "    ; Se houve borrow (R < 0), restaura o resto\n"
                    "    BRCS  restore_remainder\n"
                    "    ; Se não houve borrow, seta o LSB do quociente\n"
                    "    LDI   R16, 0x01\n"
                    "    OR    R0, R16\n"
                    "    RJMP  div_iter_done_restoring\n"
                    "\n"
                    "restore_remainder:\n"
                    "    MOV   R2, R5           ; Restaura o resto\n"
                    "    MOV   R3, R6\n"
                    "\n"
                    "div_iter_done_restoring:\n"
                    "    DEC   R17\n"
                    "    BRNE  div_loop_restoring\n"
                    "\n"
                    "    ; --- Normalização do Quociente ---\n"
                    "    ; Se o quociente estiver \"grande\" demais, faz shift right para normalizar\n"
                    "    TST   R1\n"
                    "    BRMI  norm_shift_right   ; Se o bit de sinal (MSB) estiver 1, normaliza com shift right\n"
                    "    SBRS  R1, 4              ; Se bit 4 de R1 estiver setado, também precisa de shift right\n"
                    "    RJMP  norm_find_msb\n"
                    "\n"
                    "norm_shift_right:\n"
                    "    CLR   R7                ; Zera o sticky\n"
                    "    OR    R2, R3            ; Se resto ≠ 0, sticky = 1\n"
                    "    BRNE  set_sticky_s1\n"
                    "    TST   R0\n"
                    "    BRNE  set_sticky_s1\n"
                    "    RJMP  sticky_done_s1\n"
                    "set_sticky_s1:\n"
                    "    LDI   R16, 1\n"
                    "    OR    R7, R16           ; sticky_s1 = 1\n"
                    "sticky_done_s1:\n"
                    "    MOV   R16, R0           ; Guarda LSB como Guard (G)\n"
                    "    ANDI  R16, 0x01\n"
                    "    ; --- PRIMEIRO shift right lógico de 16 bits (quociente) ---\n"
                    "    LSR   R1               ; Desloca R1 com preenchimento zero\n"
                    "    ROR   R0               ; Desloca R0, trazendo o bit do carry\n"
                    "    ; Verifica se é necessário um segundo shift (caso bit 3 de R1 ainda esteja setado)\n"
                    "    SBRS  R1, 3\n"
                    "    RJMP  rounding_check\n"
                    "    ; --- SEGUNDO shift right ---\n"
                    "    OR    R7, R16          ; Atualiza sticky com o guard anterior\n"
                    "    MOV   R16, R0\n"
                    "    ANDI  R16, 0x01        ; Novo guard\n"
                    "    LSR   R1\n"
                    "    ROR   R0\n"
                    "    MOV   R6, R16          ; Guarda o guard final\n"
                    "    RJMP  rounding_check\n"
                    "\n"
                    "norm_find_msb:\n"
                    "    OR    R1, R0\n"
                    "    BRNE  norm_not_zero\n"
                    "    RJMP  pack_zero        ; Se quociente for zero, empacota como zero\n"
                    "norm_not_zero:\n"
                    "    LDI   R16, 0           ; Contador de deslocamentos (R16 = 0)\n"
                    "norm_shift_left_loop:\n"
                    "    SBRS  R1, 3            ; Verifica se o bit de posição 3 (posição normalizada) está setado\n"
                    "    RJMP  found_msb_pos\n"
                    "    LSL   R0\n"
                    "    ROL   R1\n"
                    "    INC   R16\n"
                    "    CPI   R16, 16\n"
                    "    BREQ  norm_done        ; Caso de segurança\n"
                    "    RJMP  norm_shift_left_loop\n"
                    "found_msb_pos:\n"
                    "    SUB   R20, R16         ; Ajusta o expoente conforme o número de shifts\n"
                    "    RJMP  norm_done\n"
                    "\n"
                    "rounding_check:\n"
                    "    TST   R6\n"
                    "    BREQ  norm_done        ; Se guard = 0, não arredonda\n"
                    "    TST   R7\n"
                    "    BRNE  round_up        ; Se sticky = 1, arredonda para cima\n"
                    "    SBRS  R0, 0\n"
                    "    RJMP  round_up\n"
                    "    RJMP  norm_done\n"
                    "\n"
                    "round_up:\n"
                    "    INC   R0              ; Incrementa o quociente para arredondar\n"
                    "    BRNE  skip_inc_r1\n"
                    "    INC   R1\n"
                    "skip_inc_r1:\n"
                    "    SBRS  R1, 3           ; Verifica se houve overflow na mantissa por arredondamento\n"
                    "    RJMP  norm_done\n"
                    "    INC   R20\n"
                    "\n"
                    "norm_done:\n"
                    "    ; --- Verificação de Overflow/Underflow do Expoente ---\n"
                    "check_exponent:\n"
                    "    CPI   R20, 31\n"
                    "    BRLO  exp_not_overflow\n"
                    "    RJMP  pack_infinity\n"
                    "exp_not_overflow:\n"
                    "    CPI   R20, 1\n"
                    "    BRLO  handle_underflow\n"
                    "    RJMP  pack_normal\n"
                    "\n"
                    "handle_underflow:\n"
                    "    MOV   R16, R20\n"
                    "    NEG   R16\n"
                    "    INC   R16\n"
                    "    CLR   R6\n"
                    "underflow_shift_loop:\n"
                    "    CPI   R16, 0\n"
                    "    BREQ  pack_denormal\n"
                    "    SEC\n"
                    "    SBRC  R0, 0\n"
                    "    CLC\n"
                    "    BRCC skip_set_sticky\n"
                    "    LDI   R17, 1\n"
                    "    OR    R6, R17\n"
                    "skip_set_sticky:\n"
                    "    LSR   R1\n"
                    "    ROR   R0\n"
                    "    DEC   R16\n"
                    "    RJMP  underflow_shift_loop\n"
                    "\n"
                    "pack_denormal:\n"
                    "    BRCS  denorm_guard_is_1\n"
                    "    RJMP  pack_denorm_final\n"
                    "denorm_guard_is_1:\n"
                    "    TST   R6\n"
                    "    BRNE  denorm_round_up\n"
                    "    SBRS  R0, 0\n"
                    "    RJMP  denorm_round_up\n"
                    "    RJMP  pack_denorm_final\n"
                    "denorm_round_up:\n"
                    "    INC   R0\n"
                    "    BRNE  skip_inc_r1_denorm\n"
                    "    INC   R1\n"
                    "skip_inc_r1_denorm:\n"
                    "    LDI   R16, 0x00\n"
                    "    CP    R0, R16\n"
                    "    BRNE  pack_denorm_final\n"
                    "    LDI   R16, 0x04\n"
                    "    CP    R1, R16\n"
                    "    BRNE  pack_denorm_final\n"
                    "    LDI   R20, 1\n"
                    "    RJMP  pack_normal\n"
                    "\n"
                    "pack_denorm_final:\n"
                    "    CLR   R20\n"
                    "    RJMP  pack_final\n"
                    "\n"
                    "pack_zero:\n"
                    "    ; Empacota zero com sinal preservado\n"
                    "    CLR   R22\n"
                    "    MOV   R23, R30\n"
                    "    RET\n"
                    "\n"
                    "pack_normal:\n"
                    "    ; Empacota número normalizado\n"
                    "    CLR   R22             ; Inicializa byte baixo do resultado\n"
                    "    ; Extrai M7 (Q8) de R1 e coloca no bit 7 de R22\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x01\n"
                    "    LSL   R16             ; Desloca 7 vezes para posicionar no bit 7\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    OR    R22, R16\n"
                    "    ; Extrai M6..M0 de R0 para os bits 6..0 de R22\n"
                    "    MOV   R16, R0\n"
                    "    LSR   R16             ; Q7..Q1 passam para bits 6..0 (Q0 é descartado)\n"
                    "    ANDI  R16, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    ; Prepara o byte alto do resultado (S:E4:E3:E2:E1:E0:M9:M8)\n"
                    "    MOV   R23, R30        ; Inicia com o sinal\n"
                    "    MOV   R16, R20\n"
                    "    LSL   R16             ; Desloca expoente 2 vezes\n"
                    "    LSL   R16\n"
                    "    ANDI  R16, 0x7C\n"
                    "    OR    R23, R16\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x06       ; Extrai M9 e M8 (bits 2 e 1 de R1)\n"
                    "    LSR   R16             ; Alinha para bits 1..0\n"
                    "    OR    R23, R16\n"
                    "    RET\n"
                    "\n"
                    "pack_final:\n"
                    "    ; Empacota o resultado para casos de underflow/denormal\n"
                    "    CLR   R22\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x01\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    LSL   R16\n"
                    "    OR    R22, R16\n"
                    "    MOV   R16, R0\n"
                    "    LSR   R16\n"
                    "    ANDI  R16, 0x7F\n"
                    "    OR    R22, R16\n"
                    "    MOV   R23, R30\n"
                    "    MOV   R16, R1\n"
                    "    ANDI  R16, 0x06\n"
                    "    LSR   R16\n"
                    "    OR    R23, R16\n"
                    "    RET\n"
                    "\n"
                    "result_nan_quietA:\n"
                    "    ; Retorna Quiet NaN baseado em A\n"
                    "    MOV   R22, R18\n"
                    "    MOV   R23, R19\n"
                    "    ORI   R23, 0x7C\n"
                    "    ORI   R23, 0x02\n"
                    "    RET\n"
                    "\n"
                    "result_nan_quietB:\n"
                    "    ; Retorna Quiet NaN baseado em B\n"
                    "    MOV   R22, R16\n"
                    "    MOV   R23, R17\n"
                    "    ORI   R23, 0x7C\n"
                    "    ORI   R23, 0x02\n"
                    "    RET\n"
                    "\n"
                    "result_nan:\n"
                    "    ; Retorna NaN genérico (0/0, Inf/Inf, etc.)\n"
                    "    LDI   R22, 0x01\n"
                    "    LDI   R23, 0x7E\n"
                    "    RET\n"
                    "\n"
                    "pack_infinity:\n"
                    "    ; Empacota Infinito (+/-) com o sinal preservado\n"
                    "    LDI   R22, 0x00\n"
                    "    LDI   R23, 0x7C\n"
                    "    OR    R23, R30\n"
                    "    RET\n\n");
}
