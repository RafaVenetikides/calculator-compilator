//
// Created by Rafael Venetikides on 03/04/25.
//

#include "../../include/operations/power_operation.h"

void op_power(FILE *outAsm) {
    fprintf(outAsm, "fp_to_uint16:\n"
                    "    ; Verificar se o input é 0.0 (0x0000)\n"
                    "    ; (Nota: Não verifica 0x8000, pois expoente é >= 0)\n"
                    "    MOV   R20, R17\n"
                    "    OR    R20, R16\n"
                    "    BRNE  fp2int_not_zero\n"
                    "    ; É zero, R17:R16 já estão 0.\n"
                    "    RET\n"
                    "fp2int_not_zero:\n"
                    "\n"
                    "    ; --- Extrair componentes do float ---\n"
                    "    ; Expoente E (bits 14-10)\n"
                    "    MOV   R20, R17       ; Copia byte alto\n"
                    "    ANDI  R20, 0x7C      ; Isola bits do expoente\n"
                    "    LSR   R20            ; Alinha para E4..E0 nos bits 4..0\n"
                    "    LSR   R20            ; R20 = E (enviesado, 1 a 30, pois não é zero nem Inf/NaN)\n"
                    "\n"
                    "    ; Mantissa m (bits 9-0)\n"
                    "    MOV   R24, R16       ; R24 = m7..m0\n"
                    "    MOV   R25, R17       ; R25 = S E4..E0 m9 m8\n"
                    "    ANDI  R25, 0x03      ; Isola m9 m8 nos bits 1..0 de R25\n"
                    "\n"
                    "    ; --- Calcular expoente não enviesado p = E - 15 ---\n"
                    "    MOV   R21, R20       ; R21 = E\n"
                    "    SUBI  R21, 15        ; R21 = p (expoente real, p >= 0 pois float representa >= 1.0)\n"
                    "\n"
                    "    ; --- Construir mantissa com bit implícito (11 bits) em R17:R16 ---\n"
                    "    ; full_m = (1 << 10) | (m9:m8 << 8) | (m7:m0)\n"
                    "    MOV   R16, R24       ; R16 = m7..m0\n"
                    "    MOV   R17, R25       ; R17 = 000000 m9 m8\n"
                    "    LDI   R20, 0x04      ; Valor do bit implícito (1 << 10) >> 8\n"
                    "    OR    R17, R20       ; R17 = 000001 m9 m8\n"
                    "                         ; Agora R17:R16 = 000001 m9 m8 m7 m6 m5 m4 m3 m2 m1 m0 (valor * 2^10)\n"
                    "\n"
                    "    ; --- Calcular quantidade de deslocamento shift = p - 10 ---\n"
                    "    SUBI  R21, 10        ; R21 = shift (pode ser negativo, zero ou positivo)\n"
                    "\n"
                    "    ; --- Deslocar full_m (R17:R16) por 'shift' (R21) posições ---\n"
                    "    ; Se shift == 0, não faz nada\n"
                    "    TST   R21\n"
                    "    BREQ  fp2int_shift_done\n"
                    "\n"
                    "    ; Verificar se é deslocamento para esquerda ou direita\n"
                    "    SBRS  R21, 7         ; Testa bit de sinal de 'shift'\n"
                    "    RJMP  fp2int_shift_left ; Pula se for positivo (esquerda)\n"
                    "\n"
                    "fp2int_shift_right:\n"
                    "    ; Deslocamento para a DIREITA por abs(shift) vezes\n"
                    "    NEG   R21            ; R21 = abs(shift)\n"
                    "fp2int_rshift_loop:\n"
                    "    CPI   R21, 0\n"
                    "    BREQ  fp2int_shift_done\n"
                    "    LSR   R17            ; Desloca R17:R16 para a direita\n"
                    "    ROR   R16\n"
                    "    DEC   R21\n"
                    "    RJMP  fp2int_rshift_loop\n"
                    "\n"
                    "fp2int_shift_left:\n"
                    "    ; Deslocamento para a ESQUERDA por shift vezes\n"
                    "fp2int_lshift_loop:\n"
                    "    CPI   R21, 0\n"
                    "    BREQ  fp2int_shift_done\n"
                    "    LSL   R16            ; Desloca R17:R16 para a esquerda\n"
                    "    ROL   R17\n"
                    "    ; (Opcional: verificar overflow - improvável no range half-precision para int16)\n"
                    "    DEC   R21\n"
                    "    RJMP  fp2int_lshift_loop\n"
                    "\n"
                    "fp2int_shift_done:\n"
                    "    ; Resultado uint16 está em R17:R16\n"
                    "    RET\n"
                    "\n"
                    "; ===========================================================================\n"
                    "; Sub-rotina: pow_pos_exp_16bit_n\n"
                    "; Potenciação por Quadratura para Expoente Positivo uint16\n"
                    "; Entrada: base (R19:R18), n (uint16 em R15:R14, n >= 1)\n"
                    "; Saída:   base^n (R23:R22)\n"
                    "; Usa:     R24:R25 (power), R26:R27 (result_accum)\n"
                    "; Clobbers: R15:R14, R16, R17, R23:R22, R24:R25, R26:R27\n"
                    "; ===========================================================================\n"
                    "pow_pos_exp_16bit_n:\n"
                    "    ; power = base\n"
                    "    MOV   R24, R19\n"
                    "    MOV   R25, R18\n"
                    "    ; result_accum = 1.0\n"
                    "    LDI   R26, 0x00\n"
                    "    LDI   R27, 0x3C\n"
                    "\n"
                    "pow_16b_loop:\n"
                    "    ; Verificar se n (R15:R14) == 0\n"
                    "    MOV   R20, R15 ; Usar R20 como temporário para não modificar n ainda\n"
                    "    OR    R20, R14\n"
                    "    BREQ  pow_16b_loop_end ; Se R15 | R14 == 0, n é zero, fim.\n"
                    "\n"
                    "    ; Verificar LSB de n (que é LSB de R14)\n"
                    "    SBRC  R14, 0             ; Pular chamada se bit 0 de n for 0\n"
                    "    RCALL multiply_result_by_power ; result_accum = result_accum * power\n"
                    "\n"
                    "    ; power = power * power\n"
                    "    RCALL square_power\n"
                    "\n"
                    "    ; n = n >> 1 (deslocamento lógico à direita de R15:R14)\n"
                    "    LSR   R15\n"
                    "    ROR   R14\n"
                    "\n"
                    "    RJMP  pow_16b_loop\n"
                    "\n"
                    "pow_16b_loop_end:\n"
                    "    ; Resultado final está em result_accum (R26:R27)\n"
                    "    MOV   R23, R26\n"
                    "    MOV   R22, R27\n"
                    "    RET\n"
                    "\n"
                    "; ===========================================================================\n"
                    "; Sub-rotinas auxiliares (multiply_result_by_power, square_power)\n"
                    "; Permanecem as mesmas da resposta anterior\n"
                    "; ===========================================================================\n"
                    "multiply_result_by_power:\n"
                    "; Op1 = result_accum (R26:R27) -> R19:R18\n"
                    "MOV   R19, R26  ; Correto: R26 é high -> R19 é high\n"
                    "MOV   R18, R27  ; Correto: R27 é low -> R18 é low\n"
                    "; Op2 = power (R24:R25) -> R17:R16\n"
                    "MOV   R17, R24  ; Correto: R24 é high -> R17 é high\n"
                    "MOV   R16, R25  ; Correto: R25 é low -> R16 é low\n"
                    "CALL  op_mult_16bits\n"
                    "; result_accum (R26:R27) = Resultado (R23:R22)\n"
                    "MOV   R26, R23  ; Correto: R23 é high -> R26 é high\n"
                    "MOV   R27, R22  ; Correto: R22 é low -> R27 é low\n"
                    "RET\n"
                    "\n"
                    "square_power:\n"
                    "    ; Op1 = power (R24:R25) -> R19:R18\n"
                    "    MOV   R19, R24\n"
                    "    MOV   R18, R25\n"
                    "    ; Op2 = power (R24:R25) -> R17:R16\n"
                    "    MOV   R17, R24\n"
                    "    MOV   R16, R25\n"
                    "    CALL  op_mult_16bits\n"
                    "    ; power (R24:R25) = Resultado (R23:R22)\n"
                    "    RET\n"
                    "\n"
                    "; ===========================================================================\n"
                    "; Função Principal: op_pow_16bits\n"
                    "; Calcula base ^ expoente, onde ambos são float16 e expoente >= 0 inteiro.\n"
                    "; Entrada: base (R19:R18), expoente (R17:R16)\n"
                    "; Saída:   resultado (R23:R22)\n"
                    "; ===========================================================================\n"
                    "op_pow_16bits:\n"
                    "    ; --- Salvar registradores que serão usados pelas sub-rotinas ---\n"
                    "    ; (Exemplo: Se precisarmos de R24-R27 após a chamada)\n"
                    "    ; PUSH R24 ... PUSH R27\n"
                    "\n"
                    "    ; --- Tratamento de Casos Especiais (Simplificado) ---\n"
                    "\n"
                    "    ; 1. Verificar Expoente 0.0 (0x0000)\n"
                    "    ; (Já ignora sinal, pois expoente é >= 0)\n"
                    "    MOV   R20, R17\n"
                    "    OR    R20, R16\n"
                    "    BRNE  pow_exp_not_zero\n"
                    "    ; Expoente é 0.0. Retorna 1.0 (0x3C00)\n"
                    "    LDI   R23, 0x3C\n"
                    "    LDI   R22, 0x00\n"
                    "    ; POP R27 ... POP R24 ; Se salvou algo\n"
                    "    RET\n"
                    "pow_exp_not_zero:\n"
                    "\n"
                    "    ; 2. Verificar Expoente NaN/Inf (Não deve ocorrer pela premissa, mas é bom)\n"
                    "    MOV   R20, R17\n"
                    "    ANDI  R20, 0x7C      ; Isola bits de expoente\n"
                    "    CPI   R20, 0x7C\n"
                    "    BRNE  pow_exp_normal\n"
                    "    ; Expoente é Inf ou NaN. Retorna NaN?\n"
                    "    RJMP  result_nan     ; (Ou outra política de erro)\n"
                    "pow_exp_normal:\n"
                    "\n"
                    "    ; 3. Verificar Base 1.0 (0x3C00)\n"
                    "    CPI   R19, 0x3C\n"
                    "    BRNE  pow_base_not_one\n"
                    "    CPI   R18, 0x00\n"
                    "    BRNE  pow_base_not_one\n"
                    "    ; Base é 1.0. Retorna 1.0\n"
                    "    ; R23 e R22 já estão com 1.0 (carregados no check do expoente 0, ou precisam ser recarregados)\n"
                    "    LDI   R23, 0x3C\n"
                    "    LDI   R22, 0x00\n"
                    "    ; POP R27 ... POP R24 ; Se salvou algo\n"
                    "    RET\n"
                    "pow_base_not_one:\n"
                    "\n"
                    "    ; 4. Verificar Base 0.0 (0x0000)\n"
                    "    ; (Ignorando sinal da base por enquanto)\n"
                    "    MOV   R20, R19\n"
                    "    ANDI  R20, 0x7F ; Ignora sinal da base\n"
                    "    OR    R20, R18\n"
                    "    BRNE  pow_base_not_zero\n"
                    "    ; Base é 0.0. Como expoente é > 0, retorna 0.0\n"
                    "    CLR   R23\n"
                    "    CLR   R22\n"
                    "    ; POP R27 ... POP R24 ; Se salvou algo\n"
                    "    RET\n"
                    "pow_base_not_zero:\n"
                    "\n"
                    "    ; TODO: Adicionar verificações para Base NaN, Base +/- Infinito...\n"
                    "\n"
                    "    ; --- Conversão e Cálculo ---\n"
                    "    ; Salvar base na pilha enquanto converte expoente\n"
                    "    PUSH  R18\n"
                    "    PUSH  R19\n"
                    "\n"
                    "    ; Converte expoente float (R17:R16) para uint16 (R17:R16)\n"
                    "    CALL  fp_to_uint16\n"
                    "\n"
                    "    ; Salvar expoente uint16 (n) em R15:R14\n"
                    "    MOV   R15, R17\n"
                    "    MOV   R14, R16\n"
                    "\n"
                    "    ; Restaurar base da pilha para R19:R18\n"
                    "    POP   R19\n"
                    "    POP   R18\n"
                    "\n"
                    "    ; Chamar rotina de exponenciação com contador de 16 bits\n"
                    "    ; Entrada: base (R19:R18), n (R15:R14)\n"
                    "    ; Saída: resultado (R23:R22)\n"
                    "    CALL  pow_pos_exp_16bit_n\n"
                    "\n"
                    "    ; --- Restaurar registradores e retornar ---\n"
                    "    ; POP R27 ... POP R24 ; Se salvou algo\n"
                    "    RET\n\n");
}
