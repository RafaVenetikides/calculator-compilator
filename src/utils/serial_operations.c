//
// Created by Rafael Venetikides on 27/03/25.
//

#include "../../include/utils/serial_operations.h"

void serial_functions(FILE *outAsm) {
    fprintf(outAsm, "program_start:\n\n");

    fprintf(outAsm, "; === Inicialização da USART0 para 9600 baud ===\n"
    "    ; Clock = 16 MHz → UBRR = (16*10^6)/(16*9600) - 1 = 103\n"
    "    LDI R16, 0x67\n"
    "    STS UBRR0L, R16\n"
    "    LDI R16, 0x00\n"
    "    STS UBRR0H, R16\n\n"

    "    ; Habilita transmissor\n"
    "    LDI R16, 0x08\n"
    "    STS UCSR0B, R16\n\n"

    "    ; Modo: assíncrono, 8 bits, sem paridade, 1 stop\n"
    "    LDI R16, 0x06\n"
    "    STS UCSR0C, R16\n\n");
}

void serial_out(FILE *outAsm) {

    fprintf(outAsm, "print:\n");


    fprintf(outAsm,"    ; === Envia resultado (R23:R22) em HEX ===\n"
                    "    MOV R16, R23\n"
                    "    RCALL send_byte_hex\n"
                    "\n"
                    "    MOV R16, R22\n"
                    "    RCALL send_byte_hex\n"
                    "\n"
                    "    ; envia quebra de linha\n"
                    "    LDI R16, 0x0A\n"
                    "    RCALL send_byte\n"
                    "\n"
                    "    RET\n\n");

    fprintf(outAsm, "; === Função: envia o byte em R16 via serial ===\n"
                    "send_byte:\n"
                    "    ; Espera UDR vazio\n"
                    "wait_udr:\n"
                    "    LDS R17, UCSR0A\n"
                    "    SBRS R17, UDRE0\n"
                    "    RJMP wait_udr\n"
                    "\n"
                    "    ; Envia byte\n"
                    "    STS UDR0, R16\n"
                    "    RET\n\n");

    fprintf(outAsm, "; === Função: envia R16 como 2 dígitos HEX (ASCII) ===\n"
            "send_byte_hex:\n"
            "    PUSH R16        \n"
            "    PUSH R17\n"
            "    PUSH R18\n"
            "    PUSH R19\n"
            "\n"
            "    ; nibble alto\n"
            "    MOV  R17, R16   ; cópia\n"
            "    SWAP R17\n"
            "    ANDI R17, 0x0F\n"
            "    CPI  R17, 10\n"
            "    BRLT hex_digit1\n"
            "    LDI  R19, 'A'\n"
            "    SUBI R19, 10\n"
            "    ADD  R17, R19\n"
            "    RJMP nibble_high_ready\n\n");

    fprintf(outAsm, "hex_digit1:\n"
                    "    LDI R19, '0'\n"
                    "    ADD R17, R19\n"
                    "\n"
                    "nibble_high_ready:\n"
                    "    MOV R16, R17\n"
                    "    RCALL send_byte\n"
                    "    \n"
                    "    ; nibble baixo\n"
                    "    POP R19\n"
                    "    POP R18\n"
                    "    POP R17\n"
                    "    POP R16\n"
                    "    \n"
                    "    PUSH R16\n"
                    "    PUSH R17\n"
                    "    PUSH R18\n"
                    "    PUSH R19\n"
                    "    \n"
                    "    ANDI R16, 0x0F\n"
                    "    CPI  R16, 10\n"
                    "    BRLT hex_digit2\n"
                    "    LDI  R19, 'A'\n"
                    "    SUBI R19, 10\n"
                    "    ADD  R16, R19\n"
                    "    RJMP nibble_low_ready\n\n");

    fprintf(outAsm, "hex_digit2:\n"
                    "    LDI R19, '0'\n"
                    "    ADD R16, R19\n"
                    "\n"
                    "nibble_low_ready:\n"
                    "    RCALL send_byte\n"
                    "\n"
                    "    ; Restaura a pilha na ordem inversa\n"
                    "    POP R19\n"
                    "    POP R18\n"
                    "    POP R17\n"
                    "    POP R16\n"
                    "    RET\n"
                    "\n");
}

void serial_out_decimal(FILE *outAsm) {
    fprintf(outAsm, "print_string:\n"
                    "print_string_loop:\n"
                    "    LPM R16, Z+          ; Load byte from program memory, increment Z\n"
                    "    TST R16              ; Check if it's null terminator\n"
                    "    BREQ print_string_done\n"
                    "    RCALL send_byte      ; Send the character\n"
                    "    RJMP print_string_loop\n"
                    "print_string_done:\n"
                    "    RET\n"
                    "\n"
                    "; ===========================================================================\n"
                    "; Helper: uint16_to_ascii\n"
                    "; Converts a 16-bit unsigned integer (R17:R16) to ASCII decimal digits and sends via USART.\n"
                    "; Input: R17:R16 = uint16 value\n"
                    "; Clobbers: R0-R5, R16, R17, R18, R19, R20 (many!) - uses division/modulo logic\n"
                    "; ===========================================================================\n"
                    "uint16_to_ascii:\n"
                    "    PUSH R16\n"
                    "    PUSH R17\n"
                    "    PUSH R18\n"
                    "    PUSH R19\n"
                    "    PUSH R20\n"
                    "    PUSH R21 ; Save more registers if needed by send_byte or div/mod routine\n"
                    "\n"
                    "    ; Use registers R19:R18 for the number, R17:R16 for divisor (10000, 1000, ...)\n"
                    "    MOV R18, R16\n"
                    "    MOV R19, R17\n"
                    "\n"
                    "    ; Flag to suppress leading zeros\n"
                    "    LDI R20, 1 ; R20 = 1 means suppress zeros\n"
                    "\n"
                    "    ; Divide by 10000\n"
                    "    LDI R17, HIGH(10000)\n"
                    "    LDI R16, LOW(10000)\n"
                    "    RCALL udiv16_get_digit ; R0 = digit, R19:R18 = remainder\n"
                    "    RCALL print_digit_maybe_zero\n"
                    "\n"
                    "    ; Divide remainder by 1000\n"
                    "    LDI R17, HIGH(1000)\n"
                    "    LDI R16, LOW(1000)\n"
                    "    RCALL udiv16_get_digit ; R0 = digit, R19:R18 = remainder\n"
                    "    RCALL print_digit_maybe_zero\n"
                    "\n"
                    "    ; Divide remainder by 100\n"
                    "    LDI R17, HIGH(100)\n"
                    "    LDI R16, LOW(100)\n"
                    "    RCALL udiv16_get_digit ; R0 = digit, R19:R18 = remainder\n"
                    "    RCALL print_digit_maybe_zero\n"
                    "\n"
                    "    ; Divide remainder by 10\n"
                    "    LDI R17, HIGH(10)\n"
                    "    LDI R16, LOW(10)\n"
                    "    RCALL udiv16_get_digit ; R0 = digit, R19:R18 = remainder\n"
                    "    RCALL print_digit_maybe_zero\n"
                    "\n"
                    "    ; The last remainder is the units digit (R18 contains it, R19 is 0)\n"
                    "    MOV R0, R18\n"
                    "    ; Always print the last digit (units place)\n"
                    "    LDI R16, '0'\n"
                    "    ADD R16, R0\n"
                    "    RCALL send_byte\n"
                    "\n"
                    "restore_regs_and_ret:\n"
                    "    POP R21\n"
                    "    POP R20\n"
                    "    POP R19\n"
                    "    POP R18\n"
                    "    POP R17\n"
                    "    POP R16\n"
                    "    RET\n"
                    "\n"
                    "; --- Helper for uint16_to_ascii ---\n"
                    "print_digit_maybe_zero:\n"
                    "    ; Input: R0 = digit, R20 = leading_zero_suppress_flag\n"
                    "    ; Output: Sends digit if R0!=0 or flag==0. Updates flag.\n"
                    "    PUSH R0\n"
                    "    PUSH R16 ; Save R16 as send_byte uses it\n"
                    "    TST R0    ; Check if digit is zero\n"
                    "    BRNE print_it\n"
                    "    TST R20   ; If digit is zero, check suppress flag\n"
                    "    BRNE skip_print ; If flag is 1 (suppress), skip\n"
                    "print_it:\n"
                    "    LDI R20, 0 ; Digit is non-zero or flag was already 0, disable suppression\n"
                    "    LDI R16, '0'\n"
                    "    ADD R16, R0\n"
                    "    RCALL send_byte\n"
                    "skip_print:\n"
                    "    POP R16\n"
                    "    POP R0\n"
                    "    RET\n"
                    "\n"
                    "; --- Helper for uint16_to_ascii: 16/16 bit unsigned division ---\n"
                    "; Input: R19:R18 = Dividend, R17:R16 = Divisor\n"
                    "; Output: R0 = Quotient Digit (single, 0-9 assumed for this context), R19:R18 = Remainder\n"
                    "; Clobbers: R0-R5 (typical for division routines)\n"
                    "udiv16_get_digit:\n"
                    "    ; Basic implementation: Repeated Subtraction (can be slow)\n"
                    "    ; A faster division algorithm would be better for performance.\n"
                    "    CLR R0             ; R0 = quotient counter (digit)\n"
                    "udiv_loop:\n"
                    "    ; Compare dividend (R19:R18) with divisor (R17:R16)\n"
                    "    CP R18, R16\n"
                    "    CPC R19, R17\n"
                    "    BRCC can_subtract ; If dividend >= divisor, subtract\n"
                    "    RJMP udiv_done    ; Else, division finished for this place value\n"
                    "can_subtract:\n"
                    "    SUB R18, R16       ; R19:R18 = R19:R18 - R17:R16\n"
                    "    SBC R19, R17\n"
                    "    INC R0             ; Increment quotient digit\n"
                    "    RJMP udiv_loop\n"
                    "udiv_done:\n"
                    "    RET\n"
                    "\n"
                    "\n"
                    "; ===========================================================================\n"
                    "; Function: print_float_decimal\n"
                    "; Prints the half-precision float in R23:R22 as decimal ASCII via USART.\n"
                    "; Input: R23:R22 = half-precision float\n"
                    "; Clobbers: Many registers (R0-R7, R16-R27, R30, R31, Z)\n"
                    "; ===========================================================================\n"
                    "print_float_decimal:\n"
                    "    ; Save registers that might be used by callees or need preservation\n"
                    "    PUSH R2 ; Example - save registers as needed\n"
                    "    PUSH R3\n"
                    "    ; ... push others ...\n"
                    "    PUSH R16\n"
                    "    PUSH R17\n"
                    "    PUSH R18\n"
                    "    PUSH R19\n"
                    "    PUSH R20\n"
                    "    PUSH R21\n"
                    "    PUSH R22 ; Save original float value low\n"
                    "    PUSH R23 ; Save original float value high\n"
                    "    PUSH R24\n"
                    "    PUSH R25\n"
                    "    PUSH R26\n"
                    "    PUSH R27\n"
                    "    PUSH R30\n"
                    "    PUSH R31\n"
                    "\n"
                    "    ; --- Extract Components ---\n"
                    "    MOV R18, R22      ; R18 = low byte (m7..m0)\n"
                    "    MOV R19, R23      ; R19 = high byte (S E4..E0 m9 m8)\n"
                    "\n"
                    "    ; Extract Sign (S) -> R20\n"
                    "    MOV R20, R19\n"
                    "    ANDI R20, 0x80\n"
                    "\n"
                    "    ; Extract Biased Exponent (E) -> R21\n"
                    "    MOV R21, R19\n"
                    "    ANDI R21, 0x7C      ; Isolate E4..E0\n"
                    "    LSR R21\n"
                    "    LSR R21             ; R21 = E (0-31)\n"
                    "\n"
                    "    ; Extract Mantissa bits (m) -> R25:R24 (m9:m8 in low bits of R25, m7:m0 in R24)\n"
                    "    MOV R24, R18      ; R24 = m7..m0\n"
                    "    MOV R25, R19\n"
                    "    ANDI R25, 0x03      ; R25 = 000000 m9 m8\n"
                    "\n"
                    "    ; --- Handle Special Cases ---\n"
                    "    CPI R21, 0x1F       ; Check if E == 31 (Max exponent)\n"
                    "    BRNE fpdec_not_special\n"
                    "\n"
                    "    ; E == 31: Check Mantissa for Inf/NaN\n"
                    "    MOV R26, R25\n"
                    "    OR R26, R24         ; R26 = m9..m0\n"
                    "    TST R26             ; Check if mantissa is zero\n"
                    "    BRNE fpdec_nan     ; Mantissa non-zero -> NaN\n"
                    "\n"
                    "    ; E == 31, Mantissa == 0 -> Infinity\n"
                    "    TST R20             ; Check sign bit in R20\n"
                    "    BRNE fpdec_neg_inf\n"
                    "fpdec_pos_inf:\n"
                    "    LDI ZL, LOW(str_inf * 2)\n"
                    "    LDI ZH, HIGH(str_inf * 2)\n"
                    "    RCALL print_string\n"
                    "    RJMP fpdec_end\n"
                    "fpdec_neg_inf:\n"
                    "    LDI ZL, LOW(str_neg_inf * 2)\n"
                    "    LDI ZH, HIGH(str_neg_inf * 2)\n"
                    "    RCALL print_string\n"
                    "    RJMP fpdec_end\n"
                    "fpdec_nan:\n"
                    "    LDI ZL, LOW(str_nan * 2)\n"
                    "    LDI ZH, HIGH(str_nan * 2)\n"
                    "    RCALL print_string\n"
                    "    RJMP fpdec_end\n"
                    "\n"
                    "fpdec_not_special:\n"
                    "    ; Check for Zero (E == 0 and Mantissa == 0)\n"
                    "    TST R21             ; Check if E == 0\n"
                    "    BRNE fpdec_not_zero\n"
                    "    ; E == 0: Check Mantissa\n"
                    "    MOV R26, R25\n"
                    "    OR R26, R24         ; R26 = m9.m0\n"
                    "    TST R26\n"
                    "    BRNE fpdec_denormal ; E=0, Mantissa!=0 -> Denormal\n"
                    "    ; E == 0, Mantissa == 0 -> Zero\n"
                    "    LDI ZL, LOW(str_zero * 2)\n"
                    "    LDI ZH, HIGH(str_zero * 2)\n"
                    "    RCALL print_string\n"
                    "    RJMP fpdec_end\n"
                    "\n"
                    "fpdec_not_zero:\n"
                    "    ; --- Handle Normal Numbers ---\n"
                    "    ; Print sign if negative\n"
                    "    TST R20             ; Check sign bit\n"
                    "    BREQ fpdec_positive\n"
                    "    LDI R16, '-'\n"
                    "    RCALL send_byte\n"
                    "fpdec_positive:\n"
                    "\n"
                    "    ; Add implicit bit for normal numbers\n"
                    "    LDI R26, 0x04       ; Implicit bit (1 << 10) >> 8\n"
                    "    OR R25, R26         ; R25:R24 now holds 11-bit mantissa (1.m9..m0)\n"
                    "                         ; Value = (R25:R24) / 2^10\n"
                    "\n"
                    "    ; Calculate Unbiased Exponent p = E - 15 -> R27\n"
                    "    MOV R27, R21\n"
                    "    SUBI R27, 15        ; R27 = p\n"
                    "\n"
                    "    RJMP fpdec_calculate_val ; Skip denormal specific path\n"
                    "\n"
                    "fpdec_denormal:\n"
                    "    ; --- Handle Denormal Numbers ---\n"
                    "    ; Value = (0.m9..m0) * 2^-14\n"
                    "    ; Effective mantissa is R25:R24 (no implicit bit added)\n"
                    "    ; Effective exponent p = 1 - 15 = -14\n"
                    "    ; Print sign if negative\n"
                    "    TST R20\n"
                    "    BREQ fpdec_denorm_positive\n"
                    "    LDI R16, '-'\n"
                    "    RCALL send_byte\n"
                    "fpdec_denorm_positive:\n"
                    "    LDI R27, -14        ; R27 = p = -14\n"
                    "\n"
                    "fpdec_calculate_val:\n"
                    "    ; Now we have:\n"
                    "    ; R25:R24 = 11-bit Mantissa (M_full, value M_full / 2^10)\n"
                    "    ; R27     = Unbiased exponent p\n"
                    "    ; Value = (M_full / 2^10) * 2^p = M_full * 2^(p-10)\n"
                    "\n"
                    "    ; --- Calculate Integer Part ---\n"
                    "    ; We need to calculate floor(M_full * 2^(p-10))\n"
                    "    ; Use 32-bit representation for intermediate value if needed.\n"
                    "    ; Let's try simpler shift approach first.\n"
                    "    ; Target: Shift M_full (R25:R24) left by (p-10) if p>=10\n"
                    "    ;         Shift M_full (R25:R24) right by (10-p) if p<10\n"
                    "\n"
                    "    ; Calculate shift amount: shift = p - 10 -> R26\n"
                    "    MOV R26, R27\n"
                    "    SUBI R26, 10\n"
                    "\n"
                    "    ; Result integer part in R17:R16\n"
                    "    CLR R16\n"
                    "    CLR R17\n"
                    "\n"
                    "    ; Copy M_full to temp registers R19:R18\n"
                    "    MOV R18, R24\n"
                    "    MOV R19, R25\n"
                    "\n"
                    "    ; Check sign of shift amount R26\n"
                    "    TST R26\n"
                    "    BREQ fpdec_no_shift   ; shift == 0\n"
                    "    BRMI fpdec_shift_right ; shift < 0 -> right shift\n"
                    "\n"
                    "fpdec_shift_left:\n"
                    "    ; Shift left by R26 times\n"
                    "fpdec_lshift_loop:\n"
                    "    LSL R18\n"
                    "    ROL R19\n"
                    "    ; Check for overflow into R17 (bit 16)\n"
                    "    ROL R16             ; Use R16 for bits 15-8 of potential integer part\n"
                    "    ; We only really need uint16 result, check if R17 needs incrementing\n"
                    "    BRCS fpdec_lshift_overflow ; Simple overflow check\n"
                    "    DEC R26\n"
                    "    BRNE fpdec_lshift_loop\n"
                    "    RJMP fpdec_got_integer\n"
                    "\n"
                    "fpdec_lshift_overflow:\n"
                    "    ; Crude overflow handling for this example\n"
                    "    LDI ZL, LOW(str_ovf * 2)\n"
                    "    LDI ZH, HIGH(str_ovf * 2)\n"
                    "    RCALL print_string\n"
                    "    RJMP fpdec_end\n"
                    "\n"
                    "\n"
                    "fpdec_shift_right:\n"
                    "    ; Shift right by abs(R26) times\n"
                    "    NEG R26             ; R26 = abs(shift)\n"
                    "fpdec_rshift_loop:\n"
                    "    ; Keep track of the last bit shifted out for rounding (optional, skipped for simplicity)\n"
                    "    LSR R19\n"
                    "    ROR R18\n"
                    "    DEC R26\n"
                    "    BRNE fpdec_rshift_loop\n"
                    "    ; Fall through\n"
                    "\n"
                    "fpdec_no_shift:\n"
                    "    ; Se shift <= 0, a parte inteira de 8 bits está em R18\n"
                    "    MOV R16, R18\n"
                    "    CLR R17\n"
                    "    ; Em vez de imprimir aqui, só prepara e pula\n"
                    "    RJMP fpdec_got_integer\n"
                    "\n"
                    "fpdec_got_integer:\n"
                    "    ; Agora sim, imprime a parte inteira (R17:R16)\n"
                    "    RCALL uint16_to_ascii\n"
                    "\n"
                    "    ; --- Calculate and Print Fractional Part (Approximate) ---\n"
                    "    LDI R16, '.'\n"
                    "    RCALL send_byte\n"
                    "\n"
                    "    ; Get fractional bits. This is complex. Approximation:\n"
                    "    ; Take the original M_full (R25:R24)\n"
                    "    ; Calculate remaining shift (or original shift if right shift)\n"
                    "    ; Essentially, get Value - IntegerPart and multiply by 10 repeatedly.\n"
                    "\n"
                    "    ; Simple approach: Use the bits 'shifted out' during right shift, or the\n"
                    "    ; lower bits if left shift/no shift. Let's focus on p < 10 case.\n"
                    "    ; FracBits = M_full & ((1 << (10-p)) - 1)\n"
                    "    ; NumFracBits = 10 - p\n"
                    "\n"
                    "    ; Let's try a fixed number of fractional digits (e.g., 3) using M_full and p\n"
                    "    ; Requires multiplication and division/shifting, potentially 32-bit.\n"
                    "\n"
                    "    ; ---- Simplified Fractional Part for Demo ----\n"
                    "    ; This part is highly simplified and likely inaccurate.\n"
                    "    ; A proper implementation requires careful handling of precision and scaling.\n"
                    "    ; We'll just print a few zeros as placeholder.\n"
                    "    LDI R16, '0'\n"
                    "    RCALL send_byte\n"
                    "    LDI R16, '0'\n"
                    "    RCALL send_byte\n"
                    "    LDI R16, '0'\n"
                    "    RCALL send_byte\n"
                    "    ; ---- End Simplified Fractional Part ----\n"
                    "\n"
                    "fpdec_end:\n"
                    "    ; Restore registers\n"
                    "    POP R31\n"
                    "    POP R30\n"
                    "    POP R27\n"
                    "    POP R26\n"
                    "    POP R25\n"
                    "    POP R24\n"
                    "    POP R23 ; Restore original float value high\n"
                    "    POP R22 ; Restore original float value low\n"
                    "    POP R21\n"
                    "    POP R20\n"
                    "    POP R19\n"
                    "    POP R18\n"
                    "    POP R17\n"
                    "    POP R16\n"
                    "    ; ... pop others ...\n"
                    "    POP R3\n"
                    "    POP R2\n"
                    "    RET\n"
                    "\n"
                    "; --- String Constants in Program Memory ---\n"
                    "str_inf:     .db \"inf\", 0\n"
                    "str_neg_inf: .db \"-inf\", 0\n"
                    "str_nan:     .db \"nan\", 0\n"
                    "str_zero:    .db \"0.0\", 0\n"
                    "str_ovf:     .db \"ovf\", 0 ; For simple overflow indication\n");
}